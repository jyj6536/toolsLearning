# find

## 名字

find - 在目录层次结构中搜索文件

## 简介

find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression]

## 描述

本手册页记录了GNU版本的 find。GNU find 按照优先级规则（见操作符一节），通过从左到右的顺序评估给定的表达式搜索以每个给定的起点为根的目录树，直到结果已知（对于与操作，左侧为 false，而或操作左侧为 true），此时 find 移动到下一个文件名。

如果在注重安全的环境中使用 find（例如，在其他用户可写的目录中使用 find），用户应该阅读 findutils 文档的“安全考虑”一章，该章名为“查找文件”并且与 findutils 一起提供。 该文档还包含比本手册页更多的细节和讨论，因此用户可能会发现它是一个更有用的信息来源。 

## 选项

-H，-L和-P选项控制如何处理符号链接。直到第一个以 `-` 开头的参数或者 `(` 以及 `!` 为止，这些选项之后的命令行参数都会被当作待检查的文件或目录名。以 `-` 开头的参数或者 `(` 以及 `!` 之后的参数会被当作搜索哪些文件被搜索的表达式。不给定路径则使用当前路径。如果没有给定表达式则使用 `-print`（无论如何，应该考虑使用 `-print0`）。

本手册页谈到了表达式列表中的 "选项"。这些选项控制 find 的行为但是紧跟在最后一个路径名之后。如果有的话，五个“真实”的选项 -H，-L，-P，-D和 -O必须出现在最后一个路径名之前。理论上双破折号 `--` 可以用来表明剩余的参数都不是选项，但是由于 find 决定后续路径参数的结束方式的问题，这实际上是无效的：它一直读到一个表达式出现（也以 `-` 开头）。现在，如果一个路径参数以 `-` 开头，那么 find 会将其看作表达式。 因此，为了确保所有的起点都被看作起点，特别是为了防止由调用shell扩展的通配符模式被错误地当作表达式参数，通常更安全的做法是在通配符或可疑路径名前加上“./”或使用以“/”开头的绝对路径名。或者，使用GNU选项 `-files0-from` 将任意的起点传递给 find 虽然不可移植，但通常是安全的 。

**-P** 从不跟踪符号链接。这是默认行为。当 find 检查和打印文件信息并且文件是符号链接时，将从符号链接自身的属性获取信息。

**-L** 跟踪符号链接。当 find 检查和打印文件信息时，信息从符号链接所指向的文件的属性获取而不是从链接自身（除非是一个失效的符号链接或者 find 无法检查链接所指向的文件）。如果之后使用了 `-P` 选项，那么 `-noleaf` 仍然生效。如果 `-L` 处于生效状态并且 find 在搜索过程中发现了指向子目录的符号链接，那么符号链接所指向的子目录仍然会被搜索。

​	当 `-L` 选项生效时，`-type` 断言将总是匹配符号链接所指向的文件而不是链接自身（除非符号链接是失效的）。可能导致符号链接在 find 执行期间失效的行为（例如 `-delete`）会导致令人迷惑的现象。使用 `-L` 会导致断言 `-lname`  和 `-ilane` 总是返回 false。

**-H** 除了在处理命令行参数时，不要跟踪符号链接。当 find 检查和打印文件信息时，将从符号链接自身的属性获取信息。该行为的唯一例外是当一个命令行中指定的文件是一个可被解析的符号链接时。对于这种情况，信息是从链接所指向的东西中获取的（也就是说链接被跟踪了）。如果无法检查符号链接指向的文件，则将使用有关链接本身的信息作为应对。如果 `-H` 生效并且命令行中指定的某个路径是一个指向目录的符号链接，那么该目录下的内容会被检查（当然 `-maxdepth 0` 可以阻止这种行为）。

-H，-L和-P中被指定了不止一个，那么那么他么会互相覆盖；命令行中出现的最后一个会生效。由于是默认的，-P 会被认为是生效的除非指定了 -H 或 -L。

在开始任何搜索之前，find 会在命令行本身的处理过程中频繁地统计文件。

这些选项也会影响这些参数的处理方式。 具体来说，有许多测试将命令行上列出的文件与我们当前正在考虑的文件进行比较。 在每种情况下，都会检查命令行中指定的文件，并保存其某些属性。 如果命名文件实际上是一个符号链接，并且 -P 选项有效（或者如果既没有指定 -H 也没有指定 -L），用于比较的信息将从符号链接的属性中获取。 否则，它将从链接指向的文件的属性中获取。 如果 find 无法跟踪链接（例如，因为它没有足够的权限或链接指向不存在的文件），将使用链接本身的属性。

当 -H 或 -L 生效时，任何作为 `-newer` 的参数被列出的符号链接都会被跟踪，并且会从符号链接所指向的文件获取时间戳。同样的考虑适用于 -newerXY，-anewer 以及 -cnewer。

-follow 选项与 -L 的作用类似，尽管他在出现的地方生效（也就是说，如果没有使用 -L 而使用了 -follow，那么命令行中出现在 -follow 之后的符号链接都会被跟踪，之前的不会）。

**-D** debugopts 打印诊断信息；该选项有助于诊断为何 find 没有按照预期的方式工作。debug 选项应该以逗号分隔。debug 选项的兼容性在 findutils 的不同版本之间并不能得到保证。要获取完整的有效 debug 选项列表，请参考 `find -D help`。有效的 debug 选项包括：

+ exec 打印关于 -exec，-execdir，-ok 和 -okdir 的诊断信息。
+ opt 打印关于表达式树优化的诊断信息；参考 -O 选项。
+ rates 打印关于每个为此成功或失败频率的摘要。
+ search 粗略地浏览目录树。
+ stat 打印通过 stat 和 lstat 系统调用检查文件的信息。find 程序尝试最小化这些调用。
+ tree 以原始的或优化后的形式分别展示表达式树。
+ all 启用除了 help 以外的所有debug选项。
+ help 解释 debug 选项。

**-Olevel** 启用查询优化。查找程序对测试进行重新排序，以加快执行速度，同时保留整体效果；也就是说，具有副作用的断言不会相对于其他的断言进行重新排序。 在每个优化级别进行的优化如下。

+ 0 等价于优化级别 1。
+ 1  这是默认的优化级别，与传统行为相对应。 表达式会被重排列以使得只基于文件名的测试会被首先执行（例如，-name 和 -regex）。
+ 2 任何 -type 和 -xtype 测试都会在仅基于文件名的测试之后被执行，但是在任何从 inode 获取信息的测试之前执行。在许多现代版本的 Unix 上，文件类型是t通过 `readdir()` 返回的，所以这些断言的评估比需要 stat 文件的断言先执行。如果使用 `-fstype FOO` 断言并且指定了在 find 开始搜索时是未知的文件系统 `FOO`（也就是说，没有出现在’/etc/mtab‘中），那么该断言等同于 -false。
+ 3 在这个优化级别，所有基于成本的优化器都被启用。测试顺序会被改变以使得便宜的（也就是快的）测试先执行，代价更高的测试之后执行如果有必要的话。在每一个代价区间中，基于断言成功的可能性来评估先执行还是后执行。对于 -o，成功可能性大的断言先执行，而 -a 则相反。

基于成本的优化器对任何给定测试成功的可能性有固定的看法。在某些情况下，概率考虑了测试的具体性质（例如，-type f被假定比 -type c 成功的可能性更大）。当前，基于代价的优化器正在被评估。如果它实际上并没有提升 find 的性能，它家会被再次移除。相反，随着时间的推移，被证明可靠、稳健和有效的优化可以在较低的优化水平下实现。然而，默认的行为（即优化级别1）不会在 4.3.X 版本序列中被改变。findutils 测试套件在所有的优化级别中都会运行所有测试以确保结果是一致的。

## 表达式

 命令行中起始点列表之后的部分是表达式。这是一种匹配规范描述了如何匹配文件以及对匹配的文件进行什么操作。一个表达式由下列元素组成：

+ Tests 通常，Tests 基于我们关注的某系文件属性返回 ture 或者 false。例如，-empty 测试只有当当前文件是空文件时返回true。
+ Actions Actions会产生一些额外操作（例如在标准输出上打印一些输出）并且返回 true 或者 false，通常基于操作是否成功。
+ Global options 全局选项影响在命令行任何部分指定的 test 操作和 action。例如，-depth 选项使得 find 以深度优先的顺序遍历文件系统。
+ Positional options 位置选项仅仅影响紧随其后的 test 或 action。位置选项总是返回 true。例如，-regextype 是位置性的，为稍后在命令行上出现的正则表达式指定了正则表达式类型。
+ Operators 操作符将表达式内的不同元素连接起来。包括 -o （代表逻辑或）和 -a （代表逻辑与）。未指定则假定指定了 -a。

操作 -print 在所有匹配整个表达式后结果为 true 的文件上执行，除非操作包含 -prune 或 -equit 以外的操作。组织了默认 -print 操作包括：-delete, -exec, -execdir, -ok, -okdir, -fls, -fprint, -fprintf, -ls, -print 以及 -printf。

操作 -delete 行为也类以于一个选项（因为它隐含了 -depth）。

### 位置选项

位置选项总是返回 true。在命令行中，他们只影响他们后面的 tests。

+ -daystart 从今天而不是24小时之前开始测量时间（影响 -amin, -atime, -cmin, -ctime, -mmin 以及 -mtime）。 此选项仅影响稍后出现在命令行上的测试。 
+ -follow 已弃用；使用 -L 选项。符号链接解引用。隐含 -noleaf。在命令行中，-follow 仅影响紧随其后的 test。除非指定了 -L 或 -H 选项，-follow 选项改变了 -newer 断言的行为；任何 -newer 参数列表中的文件都会被解引用如果他们是符号链接。相同的考量适用于-newerXY, -anewer 以及 -cnewer。类似地，-type 断言总是匹配符号链接所指向的文件而不是链接本身。使用 -follow 导致断言 -lname 和 -ilname 总是返回 false。
+ -regextype *type* 改变命令行中其后的 -regex 和 -iregex 测试所理解的正则表达式语法。要查看所支持的正则表达式语法，使用 `-regextype help` 查看所有支持的正则表达式类型。文档 Texnfo 解释了正则表达式的含义以及不同类型之间的差异。
+ -warn, -nowarn 打开或关闭警告消息。这些警告仅适用于命令行用法，而不适用于查找目录时可能遇到的任何情况。如果标准输入是tty，默认行为对应于 -warn，否则对应于 -nowarn。如果生成了与命令行用法相关的警告消息，则 find 的退出状态不受影响。如果设置了 **POSIXLY_CORRECT** 环境变量，并且还使用了 -warn，则不会指定哪个警告（如果有）将处于活动状态。

### 全局选项

全局选项总是返回 true。全局选项对命令行中出现在前面的测试也会产生影响。为了避免混淆，全局选项应该在最后一个起始点指定，并恰好位于第一个测试，位置选项或者操作之前。如果在其他位置指定了全局选项，find 将发出警告消息，解释这可能会令人困惑。

全局选项出现在起始点列表之后，因此与 -L 选项不同，例如：

+ -d -depth 的同义词，与 FreeBSD,NetBSD, MacOS X and OpenBSD 兼容。

+ -depth 处理目录本身之前首先处理目录内容。操作 -delete 隐含 -depth。

+ -files0-from *file* 从 *file* 而不是从命令行中获取起始点。与已知的通过命令行传递参数的限制（即文件名数量限制）以及文件名与选项名冲突的固有模糊性不同，使用此选项可以安全地传递任意数量的起始点来查找。

  使用此选项和在命令行上传递起始点是互斥的，因此不允许同时使用。

  参数 *file* 是必须的。可以使用 `-files0-from -` 从标准输入流获取起始点，例如一个管道。在这种情况下，操作 -ok 和 -okidr 是不被允许的，因为他们为了得到用户确认会干扰标准输入的读取。

  *file* 中的起始点必须被 ASCII 字符 NUL 分割。两个连续的字符 NULL 是不被允许的，一个具有0长度文件名的起始点是不被允许的并且会导致稍后输出一个错误诊断信息以及非0退出码。给定的 *file* 必须包含至少一个起始点，空的 *file* 也会输出诊断信息。

  起始点的处理与往常一样，例如，除非另有阻止，否则 find 将递归到子目录中。要仅处理起始点，可以另外传递 `-maxdeph 0`。

  进一步说明：如果一个文件在输入文件中出现多次，那么它是否会被访问超过一次是不确定的。如果 *file* 在 find 的操作过程中被改变，那么结果也是不确定的。最后，在 find 退出时，命名 *file* 中的查找位置（无论是使用 -equit 还是其他方式）也是不确定的。这里的 “不确定” 意味着它可能工作，也可能不工作，或者做任何特定的事情，并且行为可能会因平台而异，或者findutils 版本而异。 

+ -help, --help 打印关于 find 的命令行使用方法并退出。

+ -ignore_readdir_race 通常，当无法 stat 一个文件时，find 会输出一个错误信息。 如果提供此选项，并且在 find 从目录中读取文件名和尝试 stat 文件之间删除了文件，则不会发出错误消息。这也适用于命令行中给出名称的文件或目录。该选项在读取命令行时生效，这意味着不能在打开该选项的情况下搜索文件系统的一部分，而在关闭该选项的状态下搜索文件的一部分（如果需要这样做，需要发出两个find命令，一个带有该选项，另一个没有该选项）。 此外，如果文件在读取父目录后消失，使用 -ignore_readder_race 选项的 find 将忽略 -delete 操作的错误：它不会输出错误诊断，并且 -delete 操作的返回代码将为true。

+ -maxdepth *levels* 从起始点开始最多递归 *levels*（一个非负整数）层。使用 `-maxdepth 0` 意味着仅仅对起始点本身执行操作和测试。

+ -mindepth levels 在 *levels*（一个非负整数）层以内的递归不要执行任何操作和测试。使用 `-mindepth 1` 意味着处理除了起始点以外的所有文件。

+ -mount 不要递归其他文件系统。别名 -xdev 以兼容某些其他版本的 find。

+ -noignore_readdir_race 抵消 `-ignore_readdir_race` 的影响。

+ -noleaf 不要通过假设目录包含的子目录比其硬链接计数少2个来进行优化。当搜索不遵循Unix目录链接约定的文件系统（如CD-ROM或MS-DOS文件系统或AFS卷装载点）时，需要此选项。普通Unix文件系统上的每个目录至少有两个硬链接：其名称和“.”条目。此外，其子目录（如果有）都有一个链接到该目录的“..”条目。当 find 检查一个目录时，在它比目录的链接计数少了2个子目录之后，它知道目录中的其余条目是非目录（目录树中的“叶”文件）。如果只需要检查文件名，则无需 stat 它们；这显著提高了搜索速度。

+ -version, --version 打印 find 的版本号并推出。

+ -xdev 不要进入位于其他文件系统的目录。

### 测试

某些测试，例如 `-newerXY` 和 `-samefile`，允许将当前正在被检查的文件与某些命令行中指定的参考文件进行比较。当使用这些测试的时候，对参考文件的解释由-H,-L和-P以及任何前序的 -follow决定，但是对参考文件仅会在命令被编译时被检查一次。如果参考文件不能被检查（例如，stat 系统调用出错），那么会输出一个错误信息，并且 find 会以非0的状态退出。

测试（-amin,-mtime, -gid, -inum, -links, -size, -uid and -used）可以指定一个数字参数 *n*：

+ +n 大于n
+ -n 小于n
+ n 等于n

支持的 test：

+ -amin *n* 上次访问文件的时间小于、大于或等于n分钟。

+ -anewer *reference* 当前文件的上次访问时间比参考文件的上次数据修改时间更近。如果-H 或 -L 处于生效状态并且 *reference* 是一个符号链接，那么总是使用该链接指向的文件的上次数据修改时间。

+ -atime *n* 上次访问文件的时间不到、超过或正好是n*24小时前。当 find 计算出文件上一次访问所经过的24小时周期的数量之后，任何小数部分都会被忽略，所以为了匹配 `-atime +1`，一个文件必须在两天之前被访问过。

+ -cmin *n* 上次文件状态修改的时间小于、大于或等于n分钟。

+ -cnewer *reference* 与anewer类似，只不过考察当前文件的状态修改时间。

+ -ctime *n* 与atime类似，只不过考察当前文件的状态修改时间。

+ -empty 文件为空，是常规文件或目录。

+ -executable 对当前用户来说可以执行的文件或者可以搜索的目录（ 在文件名解析意义上 ）。这考虑到了访问控制列表和其他权限因素，而 -perm 测试则忽略了这些因素。 这个测试使用了 access(2) 系统调用，因此可能被做UID映射（或root-squashing）的NFS服务器所欺骗，因为许多系统在客户的内核中实现了access(2)，因此不能利用服务器上的UID映射信息。 因为这个测试只基于access(2)系统调用的结果，所以不能保证这个测试成功的文件能被实际执行。

+ -false 总是返回 false。

+ -fstype *type* 文件存在于 *type* 类型的文件系统上。不同版本的 Unix 上有效的文件系统也不相同；一个不完整的、可以被某些版本的 Unix 或其他系统接受的的文件系统列表：ufs, 4.2, 4.3, nfs, tmp, mfs, S51K, S52K。可以使用 -printf 和 %F 指令来查看文件系统的类型。

+ -gid *n* 文件的 gid 小于，等于或大于 n。

+ -group *gname* 文件属于 *gname* 组（允许数字 gid）。Foo

+ -ilname *pattern* 类似于 -lname，但是匹配的时候是大小写不敏感的。例如，模式 `fo*` 和 `F??`  匹配文件名 `Foo`、`FOO`、`foo` 、`fOo`等等。模式 `*foo*` 可以匹配名为 `.foobar` 的文件。

+ -inum *n* 文件的 inode 编号 小于，等于或大于 n。 通常使用 -samefile 测试更容易。

+ -ipath *pattern* 类似于 -path，但是匹配是大小写不敏感的。

+ -iregex *pattern* 类似于 -regex，但是匹配是大小写不敏感的。

+ -iwholename *pattern* 查考-path。该选项的可可移植性比 -ipath 差。

+ -links *n* 文件的硬连接数小于，大于或等于 n。

+ -lname *pattern* 文件是一个符号链接，其内容与 shell 模式 *pattern* 匹配。特别是元字符不处理“/”或“.”。如果 -L 选项或 -follow选项有效，则除非符号链接是实效的，否则此测试将返回false。

+ -mmin *n* 上次访问文件的数据小于、大于或等于n分钟。

+ -mtime *n* 类似于 -atime，只不过考察的是文件的数据修改时间。

+ -name *pattern* 基于文件名（路径中的前导目录被移除）匹配 shell 模式 *pattern*。由于前导目录被移除，试图通过 -name 匹配的文件名中绝对不能包含斜杠，所以 `-name a/b` 不会匹配任何东西（可能需要使用 -path 代替）。除非设置了环境变量 POSIXLY_CORRECT，否则类似尝试会导致输出一个告警信息。元字符（“*”、“？”和“[]”）与文件名称开头的“.”匹配（这是findutils-4.2.2中的更改；请参阅下面的标准一致性部分）。要忽略某个目录及其下的文件，请使用-prune，而不是检查树中的每个文件；请参见该操作描述中的示例。虽然有些 shell（包括Bash）在 shell模式中赋予了括号特殊的含义，但括号并不被认为是特殊的。使用fnmatch（3）库函数执行文件名匹配。不要忘记将模式括在引号中，以防止其被shell扩展。

+ -newer *reference* 当前文件的上次数据修改时间比参考文件的上次数据修改时间更近。如果-H 或 -L 处于生效状态并且 *reference* 是一个符合链接，那么总是使用该链接指向的文件的上次数据修改时间。

+ -newerXY *reference* 如果被检查的文件的时间戳 *X* 比参考文件的时间戳 *Y* 更近则成功。字母 *X* 和 *Y* 可以下列任何字母：

  + a 文件的访问时间
  + B 文件的创建时间
  + c 文件的 inode 状态改变时间
  + m 文件的修改时间
  + t reference是一个绝对时间

  某些组合是无效的；例如，*X* 不能是 t。某些组合并没有在所有操作系统上实现；例如，B 在所有操作系统上都不支持。如果指定了 *XY* 的无效或不被支持的组合，就会产生一个致命错误。 时间规格被解释为GNU date的 -d 选项的参数。 如果试图使用一个参考文件的创建时间，而创建时间无法确定，则会产生一个致命的错误信息。 如果指定的测试引用了正在检查的文件的创建时间，则对于创建时间未知的任何文件，此测试都将失败。

+ -nogroup 没有组对应于文件的数字 gid。

+ -nouser 没有用户对应于文件的数字 uid。

+ -path *pattern* 文件名匹配 shell 模式 *pattern*。元字符没有特殊对待‘/’或者‘.’。所以，例如，`find . -path "./sr*sc"` 为一个叫做 `./src/misc` 的目录（如果存在的话）打印一个条目。使用 -prune 来忽略一整个目录树而不是检查该目录中的每一个文件。注意，模式匹配测试会从命令行中命名的起始点开始应用到整个文件名。如果相关的起点也是绝对路径，那么在这里使用绝对路径名称才有意义。这意味着该命令永远不会匹配任何内容：`find bar -path /foo/bar/myfile -print`。find将 -path 参数与正在检查的文件的目录名和基本名称的拼接进行比较。由于拼接永远不会以斜杠结尾，因此以斜杠结尾的

  -path 参数将与任何内容都不匹配（可能除了命令行上指定的起点）。HP-UX find也支持谓词路径，它是POSIX 2008标准的一部分。 

+ -perm *mode* 文件的权限位恰好是 *mode*。由于需要完全匹配，所有如果试图使用该模式的符号模式，用户可能必须指定一个更复杂的模式串。例如，`-perm g=w` 仅匹配 `0020` 模式的文件（也就是同组写权限是唯一权限的文件）。用户更可能使用 `/` 或者 `-` 模式，例如，`-perm -g=w` 匹配任何具有同组写权限的文件。请参考例子一节中的某些解释性的示例。

+ -perm -*mode* 所有权限位 *mode* 都设置的文件。在这种形势下符号模式也被接受，这通常是用户希望使用的方式。如果使用符号模式，用户必须指定 u，或者o。请参考例子一节中的某些解释性的示例。

+ -perm /*mode* 任一权限位 *mode* 被设置的文件。在这种形势下符号模式也被接受。如果使用符号模式，用户必须指定 u，或者o。请参考例子一节中的某些解释性的示例。如果没有设置模式中的权限位，则该测试将匹配任何文件（这里的想法是与-perm-000的行为一致）。

+ -perm +*mode* 已废弃。

+ -readable 匹配可以被当前用户读取的文件。这考虑到了访问控制列表和其他权限因素，而 -perm 测试则忽略了这些因素。 这个测试使用了 access(2) 系统调用，因此可能被做UID映射（或root-squashing）的NFS服务器所欺骗，因为许多系统在客户的内核中实现了access(2)，因此不能利用服务器上的UID映射信息。 因为这个测试只基于access(2)系统调用的结果，所以不能保证这个测试成功的文件能被实际执行。

+ -regex *pattern* 文件名匹配正则表达式 *pattern*。这是全路径的匹配，而不是搜索。例如，为了匹配名为 `./fubar3` 的文件可以使用正则表达式 `.*bar.` 或者 `.*b.*3` ，但是不能使用 `f.*r3`。find 默认支持的正则表达式是 `Emacs Regular Expressions`（除了 `.` 匹配换行符），但是这是可以通过`-regextype` 选项改变的。

+ -samefile *name* 于 *name* 指向相同 inode 的文件。如果 -L 处于生效状态，这可以包含符号链接。

+ -size *n*[cwbkMG] 文件使用小于，大于或等于 *n* 个单位的空间，向上取整。可用的后缀如下：

  + b 512字节的块（默认）
  + c 字节
  + w 两字节的字
  + k KiB
  + M MiB
  + G GiB

  这个大小只是由 lstat（或stat）系统调用填充的 stat 结构中的 st_size 这个成员，如上所示，向上取整。换句话说，其于 `ls -l` 得到的结果是一致的。请记住，-printf的`%k`和`%b`格式指定器对稀疏文件的处理是不同的。后缀 b 总是代表512字节的块而不是1024字节，这与 `ls -l` 的行为是不同的。

  前缀 + 和 - 通常表明大于还是小于；也就是说，正好 n 个单位的大小是不匹配的。请记住，大小会向上取整到下一个单位。因此 `-size -1M` 并不同于 `-size -1048576c`。前者只能匹配空文件，后者匹配从 0 到 1048575 字节的文件。

+ -true 总是返回 true。

+ -type *c* 文件属于 *c* 类型：

  + b 块（缓存的）文件
  + c 字符（非缓存的）文件
  + d 目录
  + p 命名管道（FIFO）
  + f 普通文件
  + l 符号链接；如果 -L 或者 -follow 选项生效那么总是返回 false，除非符号链接是无效的。如果在 -L 生效的同时相要搜索符号链接，使用 -xtype。
  + s socket
  + D door（Solaris）

  要同时搜索超过一种类型，就可以使用由逗号分隔的类型字符的组合列表。

+ -uid *n* 文件的数字 UID 小于，大于或等于 *n*。

+ -used *n* 文件上次访问距离其上次状态改变小于，大于或等于 *n* 天。

+ -user *uname* 文件属于用户 *uname*（数字 UID 也是允许的）。

+ -wholename *pattern* 参考 -path。可移植性比 -path 差。

+ -writable 参考 -readble。

+ -xtype *c* 除了文件是符号链接时，与 -type 相同。对于符号链接：如果 -H 或 -P 选项被指定，那么当文件是一个指向 c 类型的链接时返回 true；如果给定了 -L 选项，c 是 l 时返回 true。换句话说，对于符号链接，-xtype 检查 -type 不检查的文件类型。

+ -context *pattern* （仅支持 SELinux）文件的安全上下文匹配 glob *pattern*。

### 操作

+ -delete 删除文件；如果成功移除则返回 true。如果移除失败则输出一个错误信息。如果 -delete 失败，find 的退出状态将是非零的（当它最终退出时）。-delete 自动打开 -depth 选项。

  **警告**：不要忘记 find 命令行被作为一个表达式进行评估，所以把 find 放在第一个会导致 find 尝试删除指定的起始点下的所有文件。当测试一个将要使用的指定了 -delete 选项的 find 命令行时，应显式指定 -depth，以避免以后出现以外。由于 -delete 隐式指定 -depth，所以不能同时使用 -prune 和 -delete。

  在读取父目录后文件消失的情况下，find 与 -ignore_readder_race 选项一起将忽略-delete操作的错误：不会输出错误诊断信息，并且 -delete 返回 true。

+ -exec *command* ; 执行 command；如果状态0被返回则返回 true。以下所有传递给 find 的参数都被视为命令的参数，直到遇到包含“;”的参数。字符串“{}”被当前文件名替换，该文件名出现在命令的参数中的任何位置，而不仅仅是单独出现在参数中的位置，如某些版本的find。这两种构造可能都需要转义（使用“\”）或引用，以保护它们不受 shell 的扩展。有关 -exe c选项的使用示例，请参阅示例部分。为每个匹配的文件运行一次指定的命令。该命令在起始目录中执行。使用 -exec 操作存在不可避免的安全问题；用户应该改用-execdir选项。

+  -exec *command* {} + exec 操作的这个变体在选定的文件上运行指定的命令，但命令行是通过在末尾附加每个选定的文件名来构建的；命令的调用总数将远远少于匹配文件的数量。命令行的构建方式与 xargs 构建命令行的方式大致相同。命令中只允许“{}”的一个实例，并且它必须出现在末尾，紧挨着“+”；它需要转义（用“\”）或引用，以保护它不被 shell 解释。该命令在起始目录中执行。如果使用“+”形式的任何调用返回非零值作为退出状态，则 find 返回非零值退出状态。如果 find 遇到错误，有时会导致立即退出，因此某些挂起的命令可能根本无法运行。出于这个原因，`-exec my-command ... {} + -quit` 可能不会导致 `my-command` 实际运行。-exec的这个变体始终返回 true。

+ -execdir command ;

+ -execdir command {} + 与 -exec 类似，但指定的命令是从包含匹配文件的子目录运行的，该子目录通常不是用户执行 find 的目录。与 -exec 一样，如果从 shell 调用 find，则应引用{}。这是一种更安全的调用命令的方法，因为它在解析匹配文件的路径时避免了竞争条件。与 -exec 操作一样，-execdir 的“+”形式将构建一个命令行来处理多个匹配的文件，但任何给定的命令调用都只列出存在于同一子目录中的文件。如果使用此选项，则必须确保 PATH 环境变量不引用“.”；否则，攻击者可以通过在运行 -execdir 的目录中保留一个适当命名的文件来运行他们喜欢的任何命令。这同样适用于 PATH 中的条目为空或不是绝对目录名。如果使用“+”形式的任何调用返回非零值作为退出状态，则 find 返回非零值退出状态。如果find遇到错误，有时会导致立即退出，因此某些挂起的命令可能根本无法运行。操作的结果取决于+或 ; 正在使用变体；`-execdir command {} +` 始终返回true，而 `-execdir command {} ;` 仅当命令返回0时，返回true。

+ -fls *file* True；类似于 `ls -l` 但是像 -fprint 一样将输出写入 *file*。即使谓词不匹配，输出文件也总是被创建。关于文件名中的不常见字符是如何处理的请参考 **UNUSUAL FILENAMES**。

+ -fprint *file* True；将完整的文件名输出到文件 *file*。find 运行时文件不存在则创建，存在则截断。文件名 `/dev/stdout` 和 `/dev/stderr ` 被特殊处理；他们分别代表标准输出和标准错误输出。即使谓词不匹配，输出文件也总是被创建。关于文件名中的不常见字符是如何处理的请参考 **UNUSUAL FILENAMES**。

+ -fprint0 *file* True；类似于 -print0 但是像 -fprint 一样将输出写入 *file*。即使谓词不匹配，输出文件也总是被创建。关于文件名中的不常见字符是如何处理的请参考 **UNUSUAL FILENAMES**。

+ -fprintf *file* *format* True；类似于 -printf 但是像 -fprint 一样将输出写入 *file*。即使谓词不匹配，输出文件也总是被创建。关于文件名中的不常见字符是如何处理的请参考 **UNUSUAL FILENAMES**。

+ -ls True；将当前文件以 `ls -dils` 的格式打印到标准输出。以1KB的块进行计数，除非设置了环境变量 POSIXLY_CORRECT，此时会使用512字节的块。关于文件名中的不常见字符是如何处理的请参考 **UNUSUAL FILENAMES**。

+ -ok *command* ; 类似于 -exec 但是会首先询问用户。如果用户同意，命令会被执行。否则返回 false。如果命令被执行，其标准输出会被重定向到 `/dev/null`。该选项可能不能与 -files0-from 同时指定。

  将对提示的响应与一对正则表达式进行匹配，以确定它是肯定响应还是否定响应。如果设置了 POSIXLY_CORRECT 环境变量，则从系统中获取该正则表达式，否则从 find 的消息转换中获取。如果系统没有合适的定义，将使用find自己的定义。无论哪种情况，正则表达式本身的解释都会受到环境变量 LC_CTYPE（字符类）和 LC_COLLATE（字符范围和等价类）的影响。
  
+ -okdir command ; 类似于 -execdir 但是会首先以与 -ok 相同的方式询问用户。如果用户不同意，返回 false。如果命令被执行，其标准输出被重定向到 `/dev/null`。该选项可能不能与 -files0-from 同时指定。

+ -print True；在标准输出上打印完整的文件名，并且后跟一个换行符。如果正在将 find 的输出 pipe 到另一个程序中，并且正在搜索的文件极有可能包含换行符，那么应该认真考虑使用-print0选项而不是-print。关于文件名中的不常见字符是如何处理的请参考 **UNUSUAL FILENAMES**。

+ -print0 True；在标准输出上打印完整的文件名，并且后跟一个 null 字符（而不是 -print 使用的换行符）。这允许处理 find 输出的程序正确解释包含换行符或其他类型空白的文件名。此选项对应于 xargs 的-0选项。

+ -printf *format* True；在标准输出上打印 *format*，解释“\”转义和“%”指令。可以使用 [printf(3)](https://man7.org/linux/man-pages/man3/printf.3.html) C函数指定字段宽度和精度。请注意，许多字段打印为%s而不是%d，这可能意味着标志无法按预期工作。这也意味着“-”标志确实有效（它强制字段左对齐）。与 -print 不同，-printf 不会在字符串末尾添加换行符。转义和指令是： 

  + \a 警铃
  
  + \b 退格
  
  + \c 立即停止以该 *format* 打印并且刷新标准输出
  
  + \f From feed
  
  + \n 换行
  
  + \r Carriage return
  
  + \t 水平制表符
  
  + \v 垂直制表符
  
  + \0 ASCII NUL
  
  + \\\\ 字面意义的反斜杠
  
  + \NNN 编码是 NNN（八进制） 的 ASCII 字符
  
    一个后跟任何其他字符的 `\` 都会被看作普通字符，所以他们都会被输出。
  
  + %% 字面意义的百分号
  
  + %a 以 C 函数 [ctime(3)](https://man7.org/linux/man-pages/man3/ctime.3.html) 格式返回的 文件上次访问时间。
  
  + %A*k* 以 *k* 指定的格式返回文件的上次访问时间，可以是 @ 或者 C 函数 [strftime(3)](https://man7.org/linux/man-pages/man3/strftime.3.html) 的指令。下面展示了 *k* 的可能值的不完整列表。请参考 [strftime(3)](https://man7.org/linux/man-pages/man3/strftime.3.html) 的文档以获取完成列表。由于 [strftime(3)](https://man7.org/linux/man-pages/man3/strftime.3.html) 库函数实现之间的差异，某些转换规范字符可能不是在所有系统上都支持。
  
    + @ 自 `Jan. 1, 1970, 00:00 GMT` 其所经过的秒数及小数部分
  
      时间域：
  
    + H 小时（00 - 23）
  
    + I 小时（01 - 12）
  
    + k 小时（0 - 23）
  
    + l 小时（1 - 12）
  
    + M 分钟（00-  59）
  
    + p 本地 AM 或者 PM
  
    + r 时间，12小时制（hh:mm:ss [AP]M）
  
    + S 秒（00.00 - 61.00）。包括小数部分
  
    + T 时间，24小时制（hh:mm:ss.xxxxxxxxxx）
  
    + \+ 由+分隔的日期和时间，例如 `2004-04-28+22:22:05.0`。这属于 GNU 扩展。时间在当前时区中给出（可能会受到 环境变量 TZ 的设置的影响）。秒字段包含小数部分。
  
    + X 本地的时间表示（H:M:S）。秒字段包含小数部分
  
    + Z 时区（例如 EDT），没有明确的时区则不输出
  
      日期域：
  
    + a 本地的缩写工作日名称（Sun - Sat）
  
    + A 本地的工作日全名，变长（Sunday - Saturday）
  
    + b 本地的缩写月份名称（Jan - Dec）
  
    + B 本地的月份全名，变长（January - December）
  
    + c 本地日期和时间（at Nov 04 12:02:33 EST 1989）。格式与 [ctime(3)](https://man7.org/linux/man-pages/man3/ctime.3.html) 相同，因此为了保持与该格式的兼容性，秒字段中没有小数部分。
  
    + d 一月中的第几天（01 - 31）
  
    + D 日期（mm/dd/yy）
  
    + F 日期（yyyy-mm-dd）
  
    + h 与 b 相同
  
    + j 一年中的第几天（001 - 366）
  
    + m 月份（01 - 12）
  
    + U 以周日作为每周第一天计数的一周在一年中的编号（00 - 53）
  
    + w 一周中的第几天（0 - 6）
  
    + W 以周一作为每周第一天计数的一周在一年中的编号（00 - 53）
  
    + x 本地日期的表示（mm/dd/yy）
  
    + y 年份的最后两位数字（00 - 99）
  
    + Y 年（1970）
  
  + %b 以512字节的块计数的文件使用的总磁盘空间。由于磁盘空间是以文件系统块大小的倍数分配的，因此通常大于 `%s/512`，但如果文件是稀疏文件，则也可以更小
  
  + %c 以 C 函数  [ctime(3)](https://man7.org/linux/man-pages/man3/ctime.3.html) 返回的格式输出为文件上次状态改变的时间
  
  + %C*k* 以 *k* 指定的格式返回文件的上次状态改变时间，参考 %A
  
  + %d 文件在目录树中的深度；0表示文件是一个起始点
  
  + %D 以十进制表示的文件所在设备编号（stat 结构的 st_dev 字段）
  
  + %f 打印文件的基本名；文件名中的任何前导目录都会被移除（仅保留最后一个元素）。对于 `\`，结果是 `\`。请参考 **例子** 一节以获取示例
  
  + %F 文件所在的文件系统类型；可用于 -fstype
  
  + %g 文件的组名，如果没有组名则表示数字 GID
  
  + %h 目录名；文件名的前导目录（除了最后一个元素）。如果文件名不包含斜杠（因为它在当前目录中），%h 说明符将扩展为 `.`。对于本身为目录且包含斜杠（包括/）的文件，%h将扩展为空字符串。有关示例，请参见示例部分
  
  + %H 文件被发现的起始点
  
  + %i 文件的 inode 编号（十进制）
  
  + %k 以1KB的块计数的文件使用的总磁盘空间。由于磁盘空间是以文件系统块大小的倍数分配的，因此通常大于 `%s/512`，但如果文件是稀疏文件，则也可以更小
  
  + %l 符号链接的对象（如果为文件不是符号链接则为空字符串）
  
  + %m 文件的权限位（八进制）。此选项使用大多数Unix实现使用的“传统”数字，但如果特定实现使用了不寻常的八进制权限位排序，将看到文件模式的实际值与%m的输出之间的差异。通常希望在这个数字上有一个前导零，为此，应该使用#标志（例如，`%#m`）
  
  + %M 文件的权限（符号形式，类似 ls）。该指令在 findutils 4.2.5 及之后的版本中受到支持
  
  + %n 文件的硬链接数量
  
  + %p 文件名
  
  + %P 起始点被移除的文件名，文件在该起始点下被发现
  
  + %s 字节计数的文件大小
  
  + %S 文件的稀疏度。由 `BLOCKSIZE*st_blocks / st_size` 计算得到。对于特定长度的普通文件，将获得的确切值取决于系统。但是，通常稀疏文件的值小于1.0，使用间接块的文件的值可能大于1.0。通常，文件使用的块数取决于文件系统。BLOCKSIZE 的值取决于系统，但通常为512字节。如果文件大小为零，则打印的值未定义。在不支持st_blocks的系统上，文件的稀疏性假定为1.0
  
  + %t 以 C 函数  [ctime(3)](https://man7.org/linux/man-pages/man3/ctime.3.html) 返回的格式输出为文件上次修改的时间
  
  + %T*k* 以 *k* 指定的格式返回文件的上次修改时间，参考 %A
  
  + %u 文件的用户名，如果没有用户名则表示数字 UID
  
  + %U 文件的数字 UID
  
  + %y 文件的类型（类似于 `ls -l`），U=unknown（不应该出现）
  
  + %Y 文件的类型（类似于 -y），增加了跟踪符号链接：‘L’=loop，‘N’=nonexistent，‘?’表示在确定符号链接的目标时所发生的任何错误
  
  + %Z （仅支持 SELinux）文件的安全上下文
  
  + %{ %[ %( 保留未来使用
  
  “%”字符后跟任何其他字符将被丢弃，但将打印其他字符（不要依赖此，因为可能会引入其他格式字符）。格式参数末尾的“%”会导致未定义的行为，因为没有后面的字符。在某些 locals，它可能会隐藏你的门钥匙，而在其他地方，它会删除你正在阅读的小说的最后一页。
  
  %m和%d指令支持#、0和+标志，但其他指令不支持，即使它们打印数字。不支持这些标志的数字指令包括G、U、b、D、k和n。“-”格式标志是被支持的并将字段的对齐方式从右对齐（默认）更改为左对齐。
  
  关于文件名中的不常见字符是如何处理的请参考 **UNUSUAL FILENAMES**
  
+ -prune True；如果文件是一个目录，则不要进入。如果指定了 -depth，那么 -prune 是无效的。由于 -delete 隐含了 -depth，所以用户不能有效地同时使用 -delete 和 -prune。例如，为了跳过目录 `src/emacs` 及其下面的所有目录和文件，并且打印发现的其他文件的文件名，执行如下命令:

  ~~~shell
  find . -path ./src/emacs -prune -o -print
  ~~~

+ -quit 立即退出（如果没有发生错误，返回值为零）。这与 -prune 不同，因为 -prune 只适用于已修剪目录的内容，而 -quit 只会使查找立即停止。没有子进程将保持运行。在退出程序之前，将调用 `-exec…+` 或 `-execdir…+` 生成的所有命令行。执行 -quit 后，将不再处理命令行上指定的文件。 例如，`find /tmp/foo /tmp/bar -print -quit` 仅仅打印 `/tmp/foo`。

  quit的一个常见用法是在找到所需内容后停止搜索文件系统。例如，如果只想找到一个文件可以这样做：

  ```shell
  find / -name needle -print -quit
  ```

### 操作符

以优先级降序的顺序列出：

+ ( *expr* ) 强制优先级。由于括号对shell 来说是特别的，所以通常需要将其引用。本帮助手册中的许多例子使用反斜杠以达到该目的：`\(...\)` 代替 `(...)`。
+ ! *expr* 取反。该字符也需要保护以避免被 shell 解释。
+ -not *expr* 与 `! expr` 相同，但是不是 POSIX 兼容的。
+ *expr1* *expr2* 同一行的两个表达式被认为是由隐式的 -a 连接；如果 *expr1* 是 false 则不会评估 *expr2*。
+ *expr1* -a *expr2* 与 *expr1* *expr2* 相同。
+ *expr1* -and *expr2*  与 *expr1* *expr2* 相同，但是不是 POSIX 兼容的。
+ *expr1* -o *expr2* 或；如果 *expr1* 是 true 则不会评估 *expr2*。
+ *expr1* -or *expr2* 与 *expr1* -o *expr2* 相同，但是不是 POSIX 兼容的。
+ *expr1*,*expr2* 列出；*expr1* 和 *expr2* 都会被评估。*expr1* 的值会被丢弃；列表的值是 *expr2* 的值。逗号运算符可用于搜索几种不同类型的内容，但只遍历文件系统层次结构一次。-fprintf 操作可用于将各种匹配项列表到几个不同的输出到文件中。

 请注意，当隐式指定（例如，两个测试之间没有显式运算符）或显式指定时，-a的优先级高于-o。这意味着 `find . -name afile -o -name bfile -print` 永远不会打印文件。 

## 异常文件名

find 的许多操作都会导致其他用户控制下的数据打印。这包括文件名、大小、修改时间等。文件名是一个潜在的问题，因为它们可以包含除“\0”和“/”之外的任何字符。文件名中的异常字符可能会对您的终端造成意想不到的、通常不可取的事情（例如，更改某些终端上功能键的设置）。如下所述，不同的操作会对异常字符进行不同的处理。

+ -print0, -fprint0 总是打印准确的文件名，即使是输出到终端也不会作出改变。
+ -ls, -fls 不常见字符总是被转义。空白，退格，双引号会以C风格的转义被输出（例如 `\f`，`\"`）。其他不常见的字符使用八进制转义。其他不寻常的字符使用八进制转义来打印。其他可打印字符（-ls和-fls是介于八进制041和0176之间的字符）按原样打印。 
+ -printf, -fprintf 如果输出未到达终端，则按原样打印。否则，结果取决于正在使用的指令。指令%D、%F、%g、%g、%H、%Y和%Y扩展到不受文件所有者控制的值，因此按原样打印。指令%a、%b、%c、%d、%i、%k、%m、%m、%n、%s、%t、%u和%u的值由文件所有者控制，但不能用于向终端发送任意数据，因此按原样打印。引用了指令%f、%h、%l、%p和%p。此引用的执行方式与GNU ls相同。这与-ls和-fls使用的引用机制不同。如果能够决定用于find输出的格式，那么通常最好使用“\0”作为终止符，而不是使用换行符，因为文件名可以包含空格和换行符。LC_CTYPE 环境变量的设置用于确定需要引用的字符。
+ -print, -fprint 引用的处理方式与-printf和-fprintf相同。如果在脚本中使用 find，或者在匹配的文件可能具有任意名称的情况下，应该考虑使用 -print0 而不是 -print。

 -ok 和 -okdir 操作原样打印当前文件名。该行为可能在未来的版本作出改变。

## 标准一致性

为了最接近 POSIX 标准，应该设置环境变量 POSIXLY_CORRECT。下列选项在 POSIX 标准中被指定（IEEE Std 1003.1-2008, 2016 Edition）：

+ -H 支持

+ -L 支持

+ -name 支持，但是 POSIX 一致性依赖于系统库函数 [fnmatch(3)](https://man7.org/linux/man-pages/man3/fnmatch.3.html) 的 POSIX 兼容性。自 findutils-4.2.2 起，shell 元字符（例如 `*', `?' 或 `[]'）匹配前导的 `.` ,因为IEEE PASC interpretation 126需要这一点。这与之前版本的 findutils 相比是一个改变。

+ -type 支持。POSIX 支持 ‘b', ‘c', ‘d', ‘l', ‘p', ‘f' 和 ’s'。在操作系统支持的情况下 GNU find 也支持 'D'，代表 Door。此外，GNU find 允许一次指定多个由逗号分隔的类型列表。

+ -ok 支持。响应的解释根据通过设置LC_MESSAGES环境变量选择的“是”和“否”模式。当设置POSIXLY_CORRECT环境变量时，这些模式是系统对肯定（yes）或否定（no）响应的定义。请参阅系统文档了解 [nl_langinfo(3)](https://man7.org/linux/man-pages/man3/nl_langinfo.3.html)，特别是 YESEXPR 和 NOEXPR。当未设置 POSIXLY_CORRECT 时，模式将从 find 自己的消息目录中获取。

+ -newer 支持。如果指定的文件是一个符号链接，那么它总是被解引用的。这与以前的行为有所不同，以前的行为从符号链接中获取相关时间。

+ -perm 支持。如果未设置POSIXLY_CORRECT环境变量，则支持在POSIX中无效的某些模式参数（例如+a+x）以实现向后兼容性。

  其他主要选项

  主要选项-atime、-cime、-depth、-exec、-group、-links、-mtime、-nogroup、-nouser、-ok、-path、-print、-sprune、-size、-user和-xdev都受支持。 

POSIX标准指定圆括号“(”，“)”，否定“!”以及逻辑 AND/OR 运算符 -a 和 -o。所有其他选项、谓词、表达式等都是POSIX标准之外的扩展。然而，其中许多扩展并不是GNU find独有的。

POSIX 标准要求 find 检测循环：

> find实用程序应检测无限循环；即，输入先前访问的目录，该目录是所遇到的最后一个文件的祖先。当检测到无限循环时，find应将诊断信息写入标准错误，并应恢复其在层次结构中的位置或终止。

GNU find符合这些要求。包含指向祖先的硬链接的条目的目录的链接数通常会低于其他情况下的链接数。这可能意味着GNU find有时会优化访问子目录，而子目录实际上是指向祖先的链接。由于find实际上没有进入这样的子目录，因此可以避免发出诊断消息。尽管这种行为可能有些令人困惑，但实际上不太可能有人依赖这种行为。如果已使用-noleaf关闭叶优化，则将始终检查目录条目，并在适当的位置发出诊断消息。符号链接不能用于创建这样的文件系统循环，但是如果使用了 -L 选项或 -follow 选项，当 find 遇到符号链接循环时会发出诊断消息。与包含硬链接的循环一样，叶优化通常意味着 find 知道它不需要在符号链接上调用stat() 或chdir()，因此这种诊断通常是不必要的。

支持-d选项以与各种BSD系统兼容，但应该使用符合POSIX的选项-depth。 

环境变量 POSIXLY_CORRECT 不会影响 -regex 和 -iregex 测试，因为这些测试不属于 POSIX 标准。

## 环境变量

+ LANG  为未设置或为空的国际化变量提供默认值。 

+ LC_ALL 如果设置为非空字符串，则覆盖所有其他国际化变量的值。

+ LC_COLLATE POSIX标准指定此变量影响用于 -name 选项的模式匹配。GNU find 使用 [fnmatch(3)](https://man7.org/linux/man-pages/man3/fnmatch.3.html) 库函数，因此对 LC_COLLATE 的支持取决于系统库。该变量还影响对ok的响应的解释；当 LC_MESSAGES 变量选择用于解释对 -ok 的响应的实际模式时，模式中任何括号表达式的解释都将受到 LC_COLLATE 的影响。

+ LC_CTYPE  如果系统的 [fnmatch(3)](https://man7.org/linux/man-pages/man3/fnmatch.3.html) 库函数支持，该变量会影响正则表达式中使用的字符类的处理，也会影响 -name 测试。该变量还影响正则表达式中任何字符类的解释，正则表达式用于解释对 -ok 发出的提示的响应。LC_CTYPE环 境变量还将影响打印文件名时哪些字符被认为是不可打印的；请参阅“异常文件名”一节。 

+ LC_MESSAGES 确定用于国际化的 locale 设置。如果环境变量 POSIXLY_CORRECT 被设置，该选项也会影响对 -ok 操作的提示所得到的响应的解释。

+ NLSPATH 确定国际化消息目录的位置。

+ PATH 影响查找 -exec、-execdir、-ok 和- okdir 调用的可执行文件时要搜索的目录。

+ POSIXLY_CORRECT 决定 -ls 和 -fls 所使用的块大小。如果设置 POSIXLY_CORRECT，块以512字节为单位。否则以1024字节为单位。

  设置该环境变量同时默认关闭了告警信息（也就是说，隐含 -nowarn），因为POSIX要求除了 -ok 的输出之外，stderr上打印的所有消息都是诊断消息，并且必须导致非零退出状态。

  当 POSIXLY_CORRECT 没有被设置时，如果 +zzz 不是一个合法的符号模式，`-perm +zzz` 仅仅被当作 `-perm /zzz`。当 POSIXLY_CORRECT 被设置时，此种构造被当作错误。

  当设置POSIXLY_CORRECT时，-ok 操作对提示的响应将根据系统的消息目录进行解释，而不是根据 find 自己的消息翻译。

+ TZ 影响用于 -printf 和 -fprintf 的某些时间相关格式指令的时区。

## 例子

+ Simple `find|xargs` approach

  查找 `/tmp` 目录下名为 core 的文件并删除。

  ```shell
  $ find /tmp -name core -type f -print | xargs /bin/rm -f
  ```

  注意，当文件名中有任何换行符，单双引号或者空白时，该语句都不能正常工作。

+ Safer `find -print0 | xargs -0` approach

  查找 `/tmp` 目录下名为 core 的文件并删除，通过下面的方式，包含换行符，单双引号或者空白的文件或者目录名可以被正确处理。

  ```shell
  $ find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
  ```

  将 -name 测试置于 -type 测试之前以避免对每个文件都调用 [stat(2)](https://man7.org/linux/man-pages/man2/stat.2.html)。

  请注意，find 遍历层次结构打印匹配文件名的时间与 xargs 执行的进程处理该文件的时间之间仍然存在竞争。

+ Processing arbitrary starting points

  给定另一个程序 proggy 预过滤并创建一个巨大的 NUL分隔的文件列表，将这些文件作为起始点处理，找到其中的所有普通空文件：

  ```shell
  $ proggy | find -files0-from - -maxdepth 0 -type f -empty
  ```

  `-files0-from -` 意味着从标准输入读取起始点的名字，即 pipe；`-maxdepth 0` 确保只有强制指定的条目被检查不会递归进入目录（在这种情况下，一个起始点就是一个）。

+ Executing a command for each file

  在当前目录下的每一个文件上执行 *file*。

  ```shell
   $ find . -type f -exec file '{}' \;
  ```

  请注意，大括号括在单引号中，以防止它们被解释为 shell 脚本标点符号。分号同样受到反斜杠的保护，尽管在这种情况下也可以使用单引号。

  在许多情况中，出于性能和安全的原因，用户可能更喜欢 `-exec ... +` 或更好的 `-execdir ... +`。

+ Traversing the filesystem just once - for 2 different actions

  仅遍历一次文件系统，将 suid 文件和目录写入 `/root/suid.txt`，大文件写入 `/root/big.txt`。

  ```shell
  $ find / \
                        \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \
                        \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)
  ```

  本例在前两行使用连行符 `\` 指示 shell 继续读取下一行的命令。

+ Searching files by age

  在 home 目录中搜索过去24小时内被修改的文件。

  ```shell
  $ find $HOME -mtime 0
  ```

  该命令以这样的方式工作是因为每一个文件自上次修改的时间被24小时整除并且余数被丢弃。这意味着要匹配 `-mtime 0`，一个文件必须具有一次24小时之内的修改。

+ Searching files by permissions

  搜索可执行但是不可读的文件。

  ```shell
  $ find /sbin /usr/sbin -executable \! -readable -print
  ```

  搜索对于属主以及属组可读可写，但是对于其他用户可读不可写的文件。

  ```shell
  $ find . -perm 664
  ```

  满足这些标准但是同时具有其他权限（比如某些用户可执行）的文件不会匹配。

  搜索对于属主属组可读可写，其他用户可读，并且葫芦任何额外的权限位是否存在（比如，可执行位）。

  ```shell
  $ find . -perm -664
  ```

  例如，这会匹配模式为 0777 的文件。

  搜索任意用户可写的文件（属主，属组或任何其他人）。

  ```shell
   $ find . -perm /222
  ```

  搜索属主或属组可写的文件。

  ```shell
  $ find . -perm /220
  $ find . -perm /u+w,g+w
  $ find . -perm /u=w,g=w
  ```

  这三条命令做了相同的工作，但是第一条使用了八进制表示的文件模式，其他两条使用了符号模式。文件不是必须满足属主和属组可写；满足任一即可。

  搜索属主属组可写的文件。

  ```shell
  $ find . -perm -220
  $ find . -perm -g+w,u+w
  ```

  这两条命令做了相同的工作。

  一个更复杂的关于权限的搜索。

  ```shell
  $ find . -perm -444 -perm /222 \! -perm /111
  $ find . -perm -a+r -perm /a+w \! -perm /a+x
  ```

  这两条命令都是用来搜索对所有人可读（-perm -444 或 -perm -a+r），至少一个可写比特被设置（-perm /222 或者 -perm /a+w）但是任何人都不可执行（! -perm /111 或者 ! -perm /a+x）。

+ Pruning - omitting files and subdirectories

  将 `/source-dir` 拷贝到 `/dest-dir`，但是忽略名为 `.snapshot` 的文件和目录（以及他们中的任何内容）。命令同时忽略了文件名以 `~` 结尾的文件或目录（但是没有忽略他们的内容）。

  ~~~shell
  $ cd /source-dir
  $ find . -name .snapshot -prune -o \( \! -name '*~' -print0 \) \
      | cpio -pmd0 /dest-dir
  ~~~

  结构 `-prune -o \( ... -print0 \)` 是非常常用的。这里的思路是 -prune 之前的表达式匹配的东西是应该被移除的。然而，-prune 操作自身返回 true，所以后续的 -o 确保了右手边的表达式只有对不应该移除的目录才会执行（被移除的目录甚至不会被访问，所以他们的内容是无关的）。右手边的表达式放在括号中仅仅是为了更清晰。它强调了仅仅对于 -prune 没有发生作用的文件生效。由于测试之间的默认的“and”条件比 -o 优先级更高，所以无论如何这是默认的，但括号有助于显示发生了什么。

  给定以下项目目录及其关联的 SCM 管理目录，对项目的根目录进行有效搜索：

  ```shell
  $ find repo/ \
       \( -exec test -d '{}/.svn' \; \
       -or -exec test -d '{}/.git' \; \
       -or -exec test -d '{}/CVS' \; \
       \) -print -prune
  ```

  样例输出：

  ~~~shell
  repo/project1/CVS
  repo/gnu/project2/.svn
  repo/gnu/project3/.svn
  repo/gnu/project3/src/.svn
  repo/project4/.git
  ~~~

  在本例中，-prune 阻止了对已经被发现的目录的没有必要的访问（例如，不需要搜索 `project3/src` 因为早已经发现 `project3/.svn`），但是确保兄弟目录被发现（`project2` 和 `project3`）。

+ Other useful examples

  搜索多个文件类型。

  ```shell
  $ find /tmp -type f,d,l
  ```

  在目录 `/tmp` 下搜索文件，目录和符号链接，将这些类型作为逗号分隔的列表进行传递（GNU 扩展），这与移植性更好的，更长的形式是等价的：

  ```shell
  $ find /tmp \( -type f -o -type d -o -type l \)
  ```

  搜索具有特定名称 `needle` 的文件，并在找到第一个文件时立即停止。

  ```shell
  $ find / -name needle -print -quit
  ```

  演示对某些边界情况下 -printf 操作的%f和%h格式指令的解释。下面是一个包含一些输出的示例。

  ```shell
  $ find . .. / /tmp /tmp/TRACE compile compile/64/tests/find -maxdepth 0 -printf '[%h][%f]\n'
  [.][.]
  [.][..]
  [][/]
  [][tmp]
  [/tmp][TRACE]
  [.][compile]
  [compile/64/tests][find]
  ```

## 退出状态

如果所有文件都被成功处理则 find 以状态0退出，发生错误则以大于0的状态退出。这是一个非常宽泛的描述，但如果返回值为非零，则不应依赖 find 结果的正确性。 

如果发生了某些错误，find 会立刻停止，而不会执行所有指定的操作。例如，某些起始点不会被检查或者某些由 `-exec ... {} +` 或者 `-execdir ... {}` 触发的挂起的程序调用不会被调用。

## 官方文档

[find(1) — Linux manual page](https://man7.org/linux/man-pages/man1/find.1.html)
