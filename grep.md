# grep

## grep

grep打印包含一个或多个模式匹配的行。

## 目录

1. [介绍](##1. 介绍)
2. [使用grep](##2. 使用grep)
   - [2.1 命令行选项](###2.1 命令行选项)
     - [2.1.1 通用程序信息](####2.1.1 通用程序信息)
     - [2.1.2 匹配控制](####2.1.2 匹配控制)
     - [2.1.3 一般输出控制](####2.1.3 一般输出控制)
     - [2.1.4 输出行前缀控制](####2.1.4 输出行前缀控制)
     - [2.1.5 上下文行控制](####2.1.5 上下文行控制)
     - [2.1.6 文件和目录选择](####2.1.6 文件和目录选择)
     - [2.1.7 其他选项](####2.1.7 其他选项)
   - [2.2 环境变量](###2.2 环境变量)
   - [2.3 退出状态](###2.3 退出状态)
   - [2.4 grep程序](###2.4 grep程序)
3. [正则表达式](##3. 正则表达式)
   + [3.1 基本结构](###3.1 基本结构)
   + [3.2 字符类和括号表达式](###3.2 字符类和括号表达式)
   + 3.3 [特殊反斜杠表达式](###3.3 特殊反斜杠表达式)
   + [3.4 锚定](###3.4 锚定)
   + [3.5 反向引用和子表达式](###3.5 反向引用和子表达式)
   + [3.6 基本VS扩展正则表达式](###3.6 基本VS扩展正则表达式)
   + [3.7 问题正则表达式](###3.7 问题正则表达式)
   + [3.8 字符编码](###3.8 字符编码)
   + [3.9 匹配非ASCII和不可打印字符](###3.9 匹配非ASCII和不可打印字符)
4. [使用](##4. 使用)
5. [性能](##5. 性能)
6. [BUG报告](##6. BUG报告)
   + [6.1 已知BUG](###6.1 已知BUG)
7. [官方文档](##7. 官方文档)

## 1. 介绍

根据给定的一个或多个模式，grep在输入文件中进行模式匹配。当匹配到某一行时，grep会将该行拷贝到标准输出（默认行为），或者产生其他任何用户通过选项指定的输出。

 虽然grep希望对文本进行匹配，但除了可用内存外，它对输入行长度没有限制，并且可以匹配行内的任意字符。如果输入文件的最后一个字节不是换行符，grep会默默地提供一个。由于换行符也是模式列表的分隔符，因此无法匹配文本中的换行符。 

## 2. 使用grep

grep在命令行中通常如下使用

~~~shell
grep [option...] [patterns] [file...]
~~~

命令中有不定数量的可选参数和文件参数。模式参数中包含一个或多个由换行符分割的模式，当通过“-e pattern”或“-f file”选项提供模式时，该参数将被省略。

- [命令行选项](##2.1 其他选项)
- [环境变量](##2.2 环境变量)
- [退出状态](##2.3 其他选项)
- [grep程序](##2.4 grep程序)

### 2.1 命令行选项

grep支持丰富的选项：某些来自POSIX，另一些属于GNU扩展。长的选项名总是GNU扩展，即使是来自POSIX规范的选项。由POSIX指定的选项，在其简短的名称下，被明确地标记为POSIX可移植编程。一些选项的名称是为了与更早或更特殊的实现兼容而提供的。

有几个额外的选项可以控制使用哪个类型的grep匹配引擎。请参考[grep程序](###2.4 grep程序)。

- [通用程序信息](###2.1.1 通用程序信息)
- [匹配控制](###2.1.2 匹配控制)
- [一般输出控制](###2.1.3 一般输出控制)
- [输出行前缀控制](###2.1.4 输出行前缀控制)
- [上下文行控制](###2.1.5 上下文行控制)
- [文件和目录选择](###2.1.6 文件和目录选择)
- [其他选项](###2.1.7 其他选项)

#### 2.1.1 通用程序信息

+ --help

打印一条使用信息，简要地总结命令行选项和错误报告地址，然后退出。

+ -V or --version

打印grep的版本号到标准输出流。这个版本号应该包括在所有的错误报告中。

#### 2.1.2 匹配控制

+ -e patterns or --regexp=patterns

使用*patterns*作为一个或多个模式。模式内的换行符将每个模式与下一个模式分开。如果这个选项被多次使用或者与-f（--file）选项结合使用，则搜索所有给出的模式。通常情况下，当grep在shell命令中使用时，模式应该被加引号（-e是由POSIX指定的）。

+ -f file or --file=file

从*file*中获取*patterns*（每行一个）。如果这个选项被多次使用或者与-e（--regexp）选项结合使用，则搜索所有给出的模式。空文件不包含*patterns*因此不会进行任何匹配（-f是由POSIX指定的）。

+ -i or -y or ----ignore-case

忽略模式和输入数据中的大小写区别，使只有大小写区别的字符相互匹配。当字母只通过小写与大写对进行大小写区分时该选项是明确的，在其他情况下的行为是没有规定的。例如，大写的"S"在许多地区有一个不寻常的小写对应字符"ſ"（Unicode字符U+017F，LATIN SMALL LETTER LONG S），并且没有规定这个不寻常的字符是与"S"还是"s"相匹配，即使大写产生了"S"。另一个例子：德语小写字母"ß"（U+00DF，拉丁文小写字母SHARP S）通常被大写为两个字符串"SS"，但它不匹配 "SS"，也可能不匹配大写字母 "ẞ"（U+1E9E，拉丁文大写字母SHARP S），即使将后者的大小写改为前者。

-y是一个为了兼容而提供的过时选项（-i是由POSIX指定的）。

+ --no-ignore-case

不要忽略模式和输入数据中的大小写区别。这是默认行为。由于该选项与-i会互相覆盖对方，所以-y在传递给早已设置-i选项的shell脚本以抵消其影响时是有用的。

+ -v or --invert-match

反转匹配的含义以选择不匹配的行（-v是由POSIX指定的）

+ -w or --word-regexp

只选择那些含有构成整个单词的匹配内容的行。测试方法是，匹配的子串必须位于该行的开头，或者前面有一个非单词组成的字符。同样地，它必须在行尾，或者后面有一个非单词组成的字符。组成字的字符包括字母、数字和下划线。如果同时指定了-x，这个选项就没有作用。

因为-w选项可以匹配不以单词成分开始和结束的子串，它不同于用'\<'和'\>'包围正则表达式。例如，尽管'grep -w @'可以匹配只包含'@'的行，但是'grep '\<@\>''不能匹配任何行，因为'@'不是一个单词成分。请参考[特殊反斜杠表达式](###3.3 特殊反斜杠表达式)。

+ -x or --line-regexp

只选择那些整行匹配的行。对于正则表达式模式，这就像把每个模式放在括号里，然后用'^'和'$'包围（-x是由POSIX指定的）。

#### 2.1.3 一般输出控制

+ -c or --count

压缩正常输出；对于每一个输入文件输出匹配的行数。与-v选项合用输出不匹配的行数（-c是由POSIX指定的）。

+ --color[=WHEN] or --colour[=WHEN]

用转义序列包围匹配的非空字符串、匹配行、上下文行、文件名、行号、字节偏移量和分隔符（对于字段和上下文行的分组），在终端上用颜色显示它们。颜色由环境变量**GREP_COLORS**定义，默认值“ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36”用于显示红色粗体匹配文本、洋红色文件名、绿色行号、绿色字节偏移量、青色分隔符，以及其他默认终端颜色。请参考[环境变量](###2.2 环境变量)。

*WHEN*的值可以是：‘always’始终使用彩色输出；‘never’从不使用彩色输出；‘auto’在标准输出与终端设备关联且*term*环境变量表明终端支持彩色输出时使用彩色输出。朴素的--color选项等同于--color=auto；如果没有指定--color选项时默认--color=never。

+ -L or --files-without-match

压缩正常输出；打印每个输入文件的名称，这些文件通常不会打印输出。

+ -l or --files-with-matches

压缩正常输出。打印每个输入文件的名称，这些文件的输出通常都会被打印出来。对每个输入文件的扫描在第一次匹配时停止（-l是由POSIX指定的）。

+ -m num or --max-count=num

在*num*次匹配后停止。如果*num*是0,grep会立即停止，不会读取输入内容。*num*为-1代笔无穷大，grep不会停止；这是默认情况。

如果输入是来自普通文件的标准输入，并且输出的行的数量达到了*num*，grep确保标准输入在退出前正好位于最后选择的行之后，而不管是否存在后续的上下文行。这使得调用进程能够继续进行搜索。例如，下面的shell脚本就使用了它：

~~~shell
while grep -m 1 'PATTERN'
do
  echo xxxx
done < FILE
~~~

但是下面的shell脚本可能不能正常工作因为pipe不是一个普通文件：

```shell
# This probably will not work.
cat FILE |
while grep -m 1 'PATTERN'
do
  echo xxxx
done
```

当grep在选择了*num*行之后停止时，它会输出任何结尾的上下文行。当同时使用-c或--count选项时，grep不会输出大于num的计数。当同时使用-v或--invert-match选项时，grep在输出*num*个不匹配的行后停止。

+ -o or --only-matching

只打印匹配行中匹配的非空部分，每部分都在单独的输出行中。输出行使用与输入相同的定界符，如果同时使用-z（--null-data），则定界符为空字节（见[其他选项](####2.1.7 其他选项)）。

+ -q or --quiet or --silent

安静模式；不向标准输出写入任何东西。在任何匹配发生后立即以0状态退出即使检测到错误。请同时参考-s或者--no-messages选项。移植性提示：Solaris 10 版本的grep不支持-q；可移植的shell脚步通常可以将标准输出重定向到/dev/null而不是使用-q（-q是由POSIX指定的）。

+ -s or --no-messages

压缩关于不存在或不可读的文件的错误信息（-s是由POSIX指定的）。

#### 2.1.4 输出行前缀控制

当要输出几个前缀字段时，顺序总是文件名、行号和字节偏移，不管这些选项是按什么顺序指定的。

+ -b or --byte-offset

在每一行的输出前打印其在输入文件内的字节偏移量（从0开始）。如果-o或者--only-matching同时被指定则打印匹配部分自身的偏移量。

+ -H or --with-filename

在每个匹配之前打印文件名。当搜索多个文件时这是默认行为。

+ -h or --no-filename

在输出中压缩文件名前缀。当搜索的文件仅有一个（或者是标准输入）时这是默认行为。

+ --label=LABEL

将实际来自标准输入的输入显示为来自文件LABEL的输入。这对在搜索前转换文件内容的命令很有用；例如：

~~~shell
gzip -cd foo.gz | grep --label=foo -H 'some pattern'
~~~

+ -n or --line-number

在每一行的输出前打印其在输入文件内的行号（从1开始）（-n是由POSIX指定的）。

+ -T or --initial-tab

确保实际行内容的第一个字符位于一个制表符上，以便制表符的对齐方式看起来正常。这对输出内容前缀为实际内容的选项很有用：-H, -n, 和 -b。这也可以为输出的行号和字节偏移量预留空格，这样，来自一个文件的行都从同一列开始。

+ -z or --null

输出一个零字节（ASCII NUL字符），而不是通常在文件名后面的字符。例如，'grep -lZ'在每个文件名后面输出一个零字节，而不是通常的换行。这个选项使输出不模糊，即使在文件名中含有像换行这样的不寻常字符的情况下。这个选项可以与 "find -print0"、"perl -0"、"sort -z "和 "xargs -0 "等命令一起使用，以处理任意的文件名，甚至是那些包含换行符的文件名。

#### 2.1.5 上下文行控制

*上下文行*是匹配行附近的非匹配行。只有当下列选项被使用时他们才会被输出。无论这些选项如何设置，grep不会出入任何给定的行超过一次。如果-o或者--only-matching同时被指定，那么这些选项会实效同时会给出一个告警。

+ -A num or --after-context=num

输出匹配的行后的*num*行。

+ -B num or --before-context=num

输出匹配的行前的*num*行。

+ -C num or -num or --context=num

输出匹配的行前后各*num*行。

+ --group-separator=string

当使用了-A，-B或-C时，在不同的行的分组之间打印*string*而不是--。

+ --no-group-separator

当使用了-A，-B或-C时，不要再不同的行的分组之间打印分隔符。

下面是关于grep如何选择前缀字段和行内容之间的分隔符的一些要点：

+ 匹配行通常使用':'作为前缀字段和实际行内容之间的分隔符。
+ 上下文（即非匹配行）使用'-'代替。
+ 当没有指定上下文时，匹配行只是一个接一个地输出。
+ 当上下文被指定时，在输入中相邻的行形成一个组，并被一个接一个地输出，而默认情况下，在不相邻的组之间会出现一个分隔符。
+ 默认的分隔符是一个"--"行；它的存在和外观可以通过上述选项来改变。
+ 每个组可以包含几个匹配的行，当它们足够接近时，两个相邻的组就会连接起来，可以合并成一个连续的组。

#### 2.1.6 文件和目录选择

+ -a or --text

像处理文本文件一样处理二进制文件；这相当于--binary-files=text选项。

+ --binary-files=type

如果一个文件的数据或元数据表明该文件包含二进制数据，则假定该文件是*type*类型的。非文本字节表示二进制数据；这些字节要么是对当前地域编码不当的输出字节（见[环境变量](###2.2 环境变量)），要么是没有给出-z（-null-data）选项时的空输入字节（见[其他选项](####2.1.7 其他选项)）。

*type*的默认值是‘binary’，grep在发现空的输入二进制数据后不会输出，同时也不会输出包含不正确编码的数据的行。当某些输出被抑制时，grep会在任何输出之后向标准错误发送一条信息，说有一个二进制文件与之匹配。

如果*type*是‘without-match’，当发现了空的二进制输入数据时，grep会假定文件的剩余部分也不会匹配；着相当于-I选项。

如果*type*是‘text’，grep像处理文本文件一样处理二进制文件；这相当于-a选项。

当*type*为"binary"时，grep可能将非文本字节视为行结束符，即使没有-z（-null-data）选项。这意味着选择“binary”和"text"会影响到一个模式是否与一个文件匹配。例如，当类型为“binary”时，模式 "q$"可能会匹配紧随空字节的"q"，尽管当类型为“text”时，这并不匹配。相反，当类型为“binary”时，模式'.'（句号）可能不匹配空字节。

警告：-a (-binary-files=text)选项可能会输出二进制垃圾，如果输出是一个终端，并且终端驱动程序将其中一些解释为命令，这可能会产生讨厌的副作用。另一方面，在读取文本编码未知的文件时，使用-a或在环境中设置'LC_ALL='C''可能会有帮助，以便找到更多的匹配，即使这些匹配对于直接显示来说是不安全的。

+ -D action or --devices=action

如果输入文件是一个设备、FIFO或套接字，使用action来处理它。如果*action*是“read”，所有的设备都被读取，就像它们是普通文件一样。如果动作是 "skip"，设备、FIFO和套接字会被默默跳过。默认情况下，如果设备在命令行上或者使用了-R（-dereference-recursive）选项，则会被读取，如果设备是递归遇到的，并且使用了-r（-recursive）选项，则会被跳过。这个选项对通过标准输入读取的文件没有影响。

+ -d action or --directories=action

如果输入文件是一个目录，则使用action来处理它。默认情况下，*action*是”read“，这意味着目录被读取，就像它们是普通文件一样（一些操作系统和文件系统不允许这样做，会导致grep为每个目录打印错误信息或默默跳过它们）。如果*action*是"skip"，目录会被默默跳过。如果*action*是'recurse'，grep会递归地读取每个目录下的所有文件，访问命令行符号链接，跳过其他符号链接；这相当于-r选项。

+ --exclude=glob

使用通配符匹配，跳过任何名称后缀与模式*glob*匹配的命令行文件；名称后缀是整个名称，或者是名称中紧随斜线 ('/') 后面以非斜线字符开始的部分。递归搜索时，跳过任何子文件名与 glob 匹配的子文件；子文件名是最后一个斜线之后的部分。模式可以使用'*'、'？'和'['...']'作为通配符，并且使用\可以按字面意思引用通配符或反斜杠字符。

+ --exclude-from=file

跳过那些名称与从*file*中读出的任何模式相匹配的文件（使用通配符匹配，如--exclude下所述）。

+ --exclude-dir=glob

跳过任何名称后缀与*glob*模式相匹配的命令行目录。当进行递归搜索时，跳过任何其基本名称与*glob*相匹配的子目录。忽略*glob*中任何多余的尾部斜线。

+ -I

相当于--binary-files=without-match选项。

+ --include=glob

只搜索名称与*glob*匹配的文件，使用如--exclude所述的通配符匹配。如果同时提供了矛盾的--include和-exclude选项，那么后匹配的会生效。如果没有--include或--exclude匹配，文件就会被包含，除非第一个这样的选项是--include。

+ -r or --recursive

对于每个目录操参数，以递归方式读取和处理该目录中的所有文件。访问命令行中的符号链接，但跳过递归遇到的符号链接。注意，如果没有给出文件参数，grep会搜索工作目录。这与--directories=recurse选项相同。

+ -R or --dereference-recursive

对于每个目录参数，读取和处理该目录中的所有文件，递归地处理所有符号链接。

#### 2.1.7 其他选项

+ --

界定选项列表。--后面的参数即使以-开头也会被当作待处理文件。例如，'grep PAT -- -file1 file2'在名为-file1和file2的文件中搜索模式PAT。

+ --line-buffered

对标准输出使用行缓冲，不管输出设备如何。默认情况下，对于交互式设备，标准输出是行缓冲的，否则是全缓冲的。在全缓冲的情况下，输出缓冲区在满时被刷新；在行缓冲的情况下，每输出一行后都会刷新缓冲区。缓冲区的大小取决于系统。

+ -U or --binary

在区分文本和二进制I/O的平台上，当读写用户终端以外的文件时，使用后者，这样所有的输入字节都被原样读写。这覆盖了默认行为，即grep遵循操作系统的建议，使用文本或二进制I/O。在MS-Windows上，当grep使用文本I/O时，它将回车-换行读作换行，将Control-Z读作文件结束，并将换行写作回车-换行对。

+ -z or --null-data

将输入和输出的数据视为行的序列，每个行以一个零字节（ASCII NUL字符）代替换行来结束。和-Z或--null选项一样，这个选项可以和'sort -z'等命令一起使用，以处理任意的文件名。

### 2.2 环境变量

grep的行为受到数个环境变量的影响，其中最重要的是locale，该变量决定了个grep如何解释模式和数据中的字符。

LC_foo类别的locale是通过依次检查三个环境变量LC_ALL、LC_foo和LANG。这些变量中，第一个被设置的变量指定了locale。例如，如果LC_ALL没有被设置，但是LC_COLLATE被设置为'pt_BR.UTF-8'，那么LC_COLLATE类别就使用了巴西葡萄牙语的语言环境。作为一个仅适用于LC_MESSAGES的特殊情况，环境变量LANGUAGE可以包含一个用冒号分隔的语言列表，它覆盖了通常指定LC_MESSAGES类别的三个环境变量。如果没有设置这些环境变量、安装locale目录或者grep在编译时没有使用国家语言支持（NLS），则使用'C'语言。shell命令locale -a列出了当前可用的locale。

下列环境变量影响grep的行为。

+ GREP_COLOR

这个过时的变量与GREP_COLORS的交互作用令人困惑，如果它被设置而没有被GREP_COLORS所覆盖，grep会发出警告。可以用 "GREP_COLOR='mt=color'"来代替 "GREP_COLOR='color'"。

+ GREP_COLORS

该变量指定了颜色和其他属性以高亮输出中的不同部分。

它的值是一个用冒号分隔的*terminfo*功能列表，默认为`ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36`，`rv`和`ne`被省略（即为false）。两字母功能名称指的是终端“功能”，即高亮文本或改变文本颜色等能力。这些功能存储在一个在线数据库并由*terminfo*访问。非空的功能值通过终端或终端仿真器解释的选择图形渲染（SGR）命令来控制高亮显示(关于允许的值及其作为字符属性的含义，请参见文本终端文档中的章节）。

这些子串值是十进制的整数，可以用分号连接。grep负责将结果组合成一个完整的SGR序列（'\33['...'m'）。常见的连接值包括'1'表示粗体，'4'表示下划线，'5'表示闪烁，'7'表示反色，'39'表示默认前景色，'30'到'37'表示前景色，'90'到'97'表示16色模式前景色，'38;5;0'到'38;5;255'用于88色和256色模式的前景色，'49'用于默认背景色，'40'到'47'用于背景色，'100'到'107'用于16色模式的背景色，'48;5;0'到'48;5;255'用于88色和256色模式的背景色。

支持的功能如下。

sl= ：整个选定行的SGR子串（即省略-v命令行选项时的匹配行，或指定-v时的非匹配行）。然而，如果同时指定了布尔功能'rv'和-v命令行选项，它将适用于上下文匹配的行。默认是空的（即终端的默认颜色对）。

cx= ：SGR子串适用于整个上下文行（即省略-v命令行选项时的非匹配行，或指定-v时的匹配行）。然而，如果同时指定了布尔功能'rv'和-v命令行选项，它就会适用于选定的非匹配行。默认是空的（即终端的默认颜色对）。

rv ：布尔值，当指定-v命令行选项时，将'sl='和'cx='能力的含义反转（交换）。默认值是false（即忽略该功能）。

mt=01;31 ：SGR子串，用于匹配任何匹配行中的非空文本（即省略-v命令行选项时的选定行，或指定-v时的上下文行）。设置它相当于将'ms='和'mc='同时设置为相同的值。默认是在当前行的背景上有一个粗体的红色文本前景。

ms=01;31 ：SGR子字符串，用于匹配选定行中的非空文本（这只在省略了-v命令行选项的情况下使用）。当它生效时，`‘sl=’ (or ‘cx=’ if ‘rv’)`功能的效果仍然有效。默认情况是在当前行的背景上有一个粗体的红色文本前景。

mc=01;31 ：SGR子串，用于匹配上下文行中的非空文本（这只在指定了-v命令行选项时使用）。当它生效时，`'cx=’ (or ‘sl=’ if ‘rv’)`功能的效果仍然有效。默认是在当前行的背景上有一个粗体的红色文本前景。

fn=35 ：SGR子串，用于文件名前的任何内容行。默认是在终端的默认背景上有一个洋红色的文本前景。

ln=32 ：用于任何内容行前的行号的SGR子串。默认是在终端的默认背景上有一个绿色的文本前景。

bn=32 ：用于任何内容行前的字节偏移的SGR子串。默认是在终端的默认背景上有一个绿色的文本前景。

se=36 ：用于分隔符的SGR子串，在选定的行域（':'）之间、上下文行域（'-'）之间以及指定非零上下文时相邻行分组之间插入（'--'）。默认情况是在终端的默认背景上有一个青色的文本前景。

ne ：布尔值，防止每次着色项目结束时，使用行内擦除（EL）向右清除到行尾（'\33[K'）。这在不支持EL的终端上是需要的。另外，当所选择的高亮颜色不影响背景时，或者当EL太慢或导致太多闪烁时，它在``back_color_erase` (`bce`)` boolean *terminfo*功能不适用的终端上很有用。默认为false（即忽略该功能）。

注意布尔功能没有`'='... `部分。它们在默认情况下是被忽略（即false），当被指定时就变成了true。

+ LC_ALL and LC_COLLATE and LANG

这些变量指定了LC_COLLATE类别的区域设置，这可能会影响像'a-z'这样的范围表达式的解释。

+ LC_ALL and LC_CTYPE and LANG

这些变量为LC_CTYPE类别指定了区域设置，它决定了字符的类型，例如，哪些字符是空白的。这个类别还决定了字符编码。参见[字符编码](###3.8 字符编码)。

+ LANGUAGE and LC_ALL and LC_MESSAGES and LANG

这些变量指定了LC_MESSAGES类别的locale，它决定了grep对信息使用的语言。默认的"C"区域设置使用美式英语信息。

+ POSIXLY_CORRECT

如果设置了，grep的行为符合POSIX的要求；否则，grep的行为更像其他GNU程序。POSIX要求在文件名后面的选项必须被视为文件名；默认情况下，这类选项会被换位到操作数列表的前面并被视为选项。

+ TERM

这个变量指定了输出终端的类型，它可以影响--color选项的作用。见[一般输出控制](####2.1.3 一般输出控制)。

+ \_N_GNU_nonoption_argv_flags\_

（这里N是grep的数字pid）如果这个环境变量的第1个字符是'1'，不要把grep的第1个操作数看作是一个选项，即使它看起来是一个。shell可以为它运行的每个命令在环境中加入这个变量，指定哪些操作数是文件名通配符扩展的结果，因此不应该被当作选项。这种行为只适用于GNU C库，而且只有在没有设置POSIXLY_CORRECT的情况下。

不再支持grep 2.20和更早版本的GREP_OPTIONS环境变量，因为它在编写可移植脚本时引起了问题。要对grep的工作方式进行任意改变，你可以使用别名或脚本来代替。例如，如果grep在"/usr/bin "目录下，你可以将$HOME/bin预置到你的PATH中，并创建一个包含以下内容的可执行脚本$HOME/bin/grep：

~~~shell
#! /bin/sh
export PATH=/usr/bin
exec grep --color=auto --devices=skip "$@"
~~~

### 2.3 退出状态

通常情况下，如果有一行被选中则退出状态为0，没有行被选中则退出状态为1，发生错误则退出状态为2。然而如果-q或者--quiet或者--silent选项被指定并且有一行被选中，那么即使发生错误退出状态也是0。其他grep实现可能会在发生错误时以大于2的状态退出。

### 2.4 grep程序

grep在指定的输入文件中搜索包含与给定模式匹配的行。默认情况下，grep打印出匹配的行。一个名为-的文件代表标准输入。如果没有指定输入，grep会搜索工作目录。如果给定的命令行选项指定了递归，则grep会搜索标准输入。grep有四个主要的变体，由下列选项控制。

+ -G or --basic-regexp

将模式解释为基本正则表达式（BREs）。这是默认的。

- -E or --extended-regexp

将模式解释为扩展正则表达式（ERE）（-E是由POSIX指定的）。

- -F or --fixed-strings

将模式解释为固定字符串，而不是正则表达式(-F是由POSIX指定的)。

+ -P or --perl-regexp

将模式解释为与Perl兼容的正则表达式（PCREs）。对PCRE的支持将继续下去，但是当这个选项与-z（-null-data）选项结合使用时，请考虑这个选项的实验性，并注意 "grep -P "可能会对未实现的功能发出警告。

## 3. 正则表达式

正则表达式是一种描述一组字符串的模式。正则表达式的构造类似于算术表达式，通过使用各种运算符来组合较小的表达式。grep 可以理解三种不同版本的正则表达式语法：基本（BRE）、扩展（ERE）和 Perl-compatible（PCRE）。在GNU grep中，基本语法和扩展语法之间的可用功能没有区别。在其他实现中，基本正则表达式的功能较少。下面的描述适用于扩展正则表达式；基本正则表达式的差异将在后面总结。与 Perl 兼容的正则表达式提供了额外的功能，并在 pcre2syntax(3) 和 pcre2pattern(3) 手册页中有记录，但只有在系统中存在 PCRE 的情况下才能工作。

+ [基本结构](###3.1 基本结构)
+ [字符类和括号表达式](###3.2 字符类和括号表达式)
+ [特殊反斜杠表达式](###3.3 特殊反斜杠表达式)
+ [锚定](###3.4 锚定)
+ [反向引用和子表达式](###3.5 反向引用和子表达式)
+ [正则表达式：基本 vs 扩展](###3.6 基本VS扩展正则表达式)
+ [问题正则表达式](###3.7 问题正则表达式)
+ [字符编码](###3.8 字符编码)
+ [匹配非ASCII和不可打印字符](###3.9 匹配非ASCII和不可打印字符)

### 3.1 基本结构

在正则表达式中，`.?*+{|()[\^$`是特殊字符，作用如下所述。所有其他字符都是普通字符，每一个普通字符都是匹配自身的正则表达式。

句号`.`匹配任何的单个字符。`.`是否匹配错误编码是未定义的。

一个正则表达式之后可以跟随一个或数个重复操作符；以`{`开头的操作符被称为间隔操作符。

+ ? ：字符是可选的，至多匹配一次。
+ \* ：字符可匹配0次或多次。
+ \+ ：字符至少匹配一次。
+ {n} ：字符正好匹配n次。
+ {n,} ：字符至少匹配n次。
+ {,m} ：字符至多匹配m次。这是GNU扩展
+ {n,m} ：字符匹配n到m次。

空正则表达式匹配的是空字符串。两个正则表达式可以被连接起来；产生的正则表达式匹配任何由两个分别匹配连接的表达式的子字符串组成的字符串。

两个正则表达式可以用运算符`|`连接。由此产生的正则表达式可以匹配任何与这两个表达式中的任何一个相匹配的字符串，成为替代表达式。

重复优先于连接，连接又优先于替代。整个表达式可以用括号括起来，以覆盖这些优先规则并形成子表达式。不匹配的`)`仅与自身匹配。 

并不是每个字符串都是有效的正则表达式。参考[问题正则表达式](###3.7 问题正则表达式)。

### 3.2 字符类和括号表达式

括号表达式是由`[]`包裹的字符列表。它匹配任何列表中的单个字符。如果列表中的第一个字符是脱字符`^`，那么它就会匹配列表中没有的任何字符，并且没有说明它是否匹配编码错误。例如，正则表达式`[0123456789]`匹配任何单个的数字，`[^()]`匹配任何非开括号或闭括号的单个字符，可能会也可能不会匹配编码错误。在括号表达式中，范围表达式由两个用连字符分隔的字符组成。它匹配任何在这两个字符之间排序的单个字符（包括这两个字符）。在默认的C locale中，排序序列是原始的字符顺序；例如，`[a-d]`等同于`[abcd]`。在其他的locales中，排序序列是未定义的，`[a-d]`可能等同于`[abdd]`或者`[aBbCcDd]`，可能匹配不到任何字符，或者所匹配的字符集可能是不稳定的，甚至也可能是无效的。可以通过将环境遍历LC_ALL设置为c以启用传统的括号表达式。

最后，最后，某些命名的字符类在括号表达式中被预先定义，如下所示。它们的解释取决于LC_CTYPE区域设置；例如，`[[:alnum:]]`意味着当前区域设置中的数字和字母的字符类别。

+ [:alpha:]

字母：`[:lower:]`和`[:upper:]`。在c locale 和 ASCII字符编码中，这等同于`[A-Za-z]`。

+ [:blank:]

空白字符：空格和TAB。

+ [:cntrl:]

控制字符。在ASCII中，这些字符的八进制编码为000到037以及177（DEL）。在其他字符集中，如果有的话，与ASCII中是同等的字符。

+ [:digit:]

数字：0 1 2 3 4 5 6 7 8 9。

+ [:graph:]

图形化字符：`[:alnum:]`和`[:punct:]`。

+ [:lower:]

小写字母；在c locale和ASCII字符编码中是a到z。

+ [:print:]

可打印字符：`[:alnum:]`，`[:punct:]`和空格。

+ [:punct:]

标点符号：在c locale和ASCII字符编码中是如下字符：

~~~shell
! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~
~~~

+ [:space:]

空白字符；在c locale中指的是TAB，换行符，垂直TAB，换页符，回车符和空格。关于换行符的匹配请参考[使用](##4. 使用)。

+ [:upper:]

大写字母；在c locale和ASCII字符编码中是A到Z。

+ [:xdigit:]

十六进制字符：在c locale和ASCII字符编码是：`0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f`。

请注意，这些类名中的括号是符号名称的一部分，除了给括号表达式定界的括号外，还必须包括额外的括号。

如果错误地省略了外层括号，而搜索例如`[:upper:]`，GNU grep会打印出一个诊断，并以状态2退出，因为它假定使用者并没有打算搜索正则表达式`[:epru]`。

特殊字符在括号表达式中失去其特殊意义。

+ `]`如果不是第一个列表项，就会结束括号内的表达。所以，如果想让`]`字符成为列表项，必须将其放在最前面。
+ `[.`代表collating符号的开始，参开[stackoverflow](https://stackoverflow.com/questions/35042202/regex-collating-symbols)。
+ `.]`代表collating符号的结束。
+ `[=`代表等价类型的开始。
+ `=]`代表等价类型的结束。
+ `[:`代表字符类符号的开始，应该跟随一个合法的字符类名。
+ `:]`代表字符类符号的结束。
+ `-`如果不是列表中的第一个或最后一个或范围的结束点，则表示范围。要使“-”成为列表项，最好将其放在最后。
+ `^`代表字符不再列表中。如果想`^`成为一个列表元素，不要将其放在第一个位置。

### 3.3 特殊反斜杠表达式

跟随一个特殊字符的`\`是匹配特殊字符的正则表达式。当`\`后跟随某些特殊字符时具有特殊含义：

+ \b

匹配单词边缘的空字符串。

+ \B

匹配空字符串，只要它不在一个单词的边缘。

+ \\<

匹配一个单词开始处的空字符串。

+ \\>

匹配一个单词结束处的空字符串。

+ \w

匹配单词成分，是`[[:alnum:]]`的同义词。

+ \W

匹配非单词成分，`[^[:alnum:]]`的同义词。

+ \s

匹配空白字符，是`[[:space:]]`的同义词。

+ \S

匹配非空白字符，是`[^[:space:]]`的同义词。

+ \\]

匹配`]`。

+ \\}

匹配`}`。

例如，`\brat\b`匹配单独的单词rat，`\Brat\B`匹配crate但是不匹配furry rat。

如果一个未转义的反斜杠后面没有特殊字符、非零数字或上述列表中的字符，那么grep的行为就是未定义的。尽管grep现在可能会发出诊断和/或给反斜杠一个解释，但如果正则表达式的语法在未来的版本中被扩展，它的行为可能会改变。

### 3.4 锚定

脱字符`^`和dollar符`$`是特殊字符，分别匹配一行开头和结尾的空字符串。他们被称为“锚点”，因为他们分别将强制将匹配“锚定”在一行的开头或结尾。

### 3.5 反向引用和子表达式

反向引用`\b`匹配之前被正则表达式的第n个括号内的子表达式匹配的子串，这里的n是一个非零的数字。例如，`(a)\1`匹配`aa`。如果括号内的子表达式没有参与匹配，那么整个匹配就会失败；例如，`(a)*\1`无法匹配`a`。如果括号内的子表达式匹配超过一个子字符串，那么反向引用指向最后一个匹配的子字符串。`(ab*)*\1`匹配`ababbabb`，不匹配`ababbab`。如果通过-e或文件（-f file）提供了多个正则表达式，那么反向引用只在每个表达式内部生效。

对于一些反向引用的已知问题，参考[已知Bugs](###6.1 已知BUG)。

### 3.6 基本VS扩展正则表达式

基本正则表达式和扩展正则表达式的差异表现在以下几个方面：

+ 字符`?`，`+` ，`{`，`|`，`(`和`)`失去他们的特殊含义；而是使用反斜杠版本`\?`，`\+` ，`\{`，`\|`，`\(`和`\)`。另外，在区间表达式的结尾`}`前需要有一个反斜杠。
+ 不匹配的`\)`是非法的。
+ 如果一个未转义的`^`既不出现在第一个，也不直接出现在`\(`或`\|`之后，它就会被当作一个普通字符来处理，而不是一个锚点。
+ 如果一个未转义的`$`既不出现在最后一个，也不直接出现在`\(`或`\|`或锚点`^`之后，它就会被当作一个普通字符来处理，而不是一个锚点。
+ 如果一个未转义的`*`出现在第一个，或者直接出现在`\(`或`\|`或锚点`^`之后，它就会被当作一个普通字符来处理而不是重复操作符。

### 3.7 问题正则表达式

某些字符串是非法的正则表达式，会导致grep输出诊断信息或者出错。例如，由于没有括起来的子表达式以供反向引`\1`引用，`xy\1`是非法的。

同时，某些正则表达式的行为是未定义的并且应该避免使用尽管grep当前不会对他们输出诊断信息。例如，`xy\0`的行为是未定义的，因为0不是一个特殊字符，`\0`也不是特殊的反斜杠表达式（见特殊反斜杠表达式）。未指定的行为可能有很严重的问题，因为匹配的字符串集可能只是部分指定，或者根本没有指定，或者表达式甚至可能是无效的。

以下正则表达式结构在所有符合POSIX的平台上都是无效的，所以可移植脚本可以假定grep拒绝这些结构：

+ 一个基本的正则表达式包含一个反向引用`\n`，前面是少于n个的封闭括号。例如，`\(a\)\2`是无效的。
+ 一个括号正则表达式包含非字符类开头的`[`:；对于`[=`和`[.`也是类似的。例如，`[a:[:b]]`和`[a:[ouch:]b]`是无效的。

GNU grep将下列结构看作是无效的。然而，其他grep实现可能将其看作有效的，因此可移植脚本不应依赖于它们的无效性：

+ 非转义的`\`位于正则表达式结尾。
+ 非转义的`[`没有位于括号表达式的开头。
+ 基本正则表达式中的`\{`没有位于区间表达式的开头。
+ 基本正则表达式中不平衡的`\(`和`\)`，或者扩展正则表达式中多余的`(`。
+ 在POSIX locale中，类似于`z-a`这样的包含0个元素的范围表达式。在非GUN grep可能是合法的并且不匹配任何元素。
+ 重复次数超过32767的区间表达式（可移植POSIX的限制是255，即使是计数较小的区间表达式，在所有已知的实现上也会变得不切实际地慢）。
+ 一个至少包含三个元素的括号表达式，第一个和最后一个元素都是`:`，或者`.`，或者`=`。例如，非GNU grep可能把`[:alpha:]`当作`[[:alpha:]]`，或者`[:ahlp]`。

下面这些结构在GNU grep中有着明确的行为定义。然而，它们在其他地方的行为并不明确，所以可移植脚本应该避免使用它们：

+ 特殊反斜杠字符，类似于`\b`，`\<`以及`\]`。参考[特殊反斜杠字符](###3.3 特殊反斜杠表达式)。
+ 使用`\?`，`\+`或者`\|`的基本正则表达式。
+ 使用反向引用的扩展正则表达式。
+ 空的正则表达式，子表达式或者可选。例如，`(a|bc|)`是不可移植的；可移植的是`(a|bc)?`。
+ 在一个基本的正则表达式中，直接出现在`\(`之后的锚点`^`，或者直接出现在`\)`之前的锚点`$`。
+  在基本正则表达式中，直接跟随另一个重复运算符的重复运算符。
+ 在一个扩展的正则表达式中，不是一个有效的区间表达式的开始的未转义的`{`。GNU grep将`{`视为一个普通字符。
+ 模式或输入中的null字符或者编码错误。参考[字符编码](###3.8 字符编码)。
+ 输入文件以非换行符结束，GNU grep会默默提供一个换行符。

下列结构在grep的GNU和其他实现中的行为都是未定义的。脚本应该尽可能避免他们。

+ 一个转义普通字符的反斜杠，除非它是像`\1`这样的反向引用或像`\<`或`\b`这样的特殊反斜杠表达。参见[特殊反斜杠表达式](###3.3 特殊反斜杠表达式)。例如，`\x`现在的行为是未定义的，未来的grep版本可能会为`\x`指定一个新的行为。
+ 直接出现在锚点之后的，或者出现在完整的正则表达式、括号内的子表达式或可选项开头的重复操作符。例如，`+|^*(+a|?-b)`具有未定义的行为，而`\+|^\*(\+a|?-b)`是可移植的。
+ 一个在POSIX locale之外的范围表达式。例如，在某些locale，`[a-z]`可能会匹配一些不是小写字母的字符，或者不匹配一些小写字母，或者可能是无效的。在GNU grep中，并没有记录这些范围表达式是使用本地代码点，还是使用LC_COLLATE类别指定的校对序列，或者有一些其他解释。在POSIX locale之外，使用`[[:lower:]]`来匹配小写字母，或者使用`[abcdefghijklmnopqrstuvwxyz]`来匹配ASCII小写字母是可以移植的。

### 3.8 字符编码

LC_CTYPE locale设置指定了模式和数据中的字符编码，也就是说，文本是用UTF-8、ASCII还是其他编码。参见[环境变量](###2.2 环境变量)。

在"C"或"POSIX"模式下，每个字符都被编码为一个字节，每个字节都是一个有效的字符。在更复杂的编码中，如UTF-8，可能需要多个字节的序列来表示一个字符，有些字节可能是编码错误，对任何字符的表示没有帮助。POSIX没有规定当模式或输入数据包含编码错误或空字符时grep的行为，所以可移植脚本应该避免这种用法。作为对POSIX的扩展，GNU grep像对待其他字符一样对待空字符。然而，除非使用 -a (-binary-files=text) 选项，否则输入中的空字符或输出中的编码错误会导致GNU grep将文件视为二进制文件并忽略匹配的细节。参见[文件和目录选择](####2.1.6 文件和目录选择)。

无论在什么地方，POSIX便携式字符集（ASCII的一个子集）中的103个字符总是被编码为一个字节，而除了古怪的平台，128个ASCII字符在所有的平台上都有其通常的单字节编码。

### 3.9 匹配非ASCII和不可打印字符

在正则表达式中，除换行符以外的非ASCII字符和不可打印字符不是特殊字符，它们表示自己。例如，在使用UTF-8的语言环境中，命令`grep '∧	ω'`（其中`^`和`ω`之间的空格是制表符）搜索`^`（Unicode字符U+039B希腊大写字母LAMBDA），后跟制表符（U+0009 tab），后跟`ω`（U+03C9希腊小写字母OMEGA）。

假设用户希望将模式限制在只有可打印的字符（甚至只有可打印的ASCII字符），以保持的脚本的可读性或可移植性，但同时也希望匹配特定的非ASCII或非空的不可打印的字符。如果使用的是-P（-perl-regexp）选项，PCREs会提供方法来做到这一点。否则，如果使用Bash，GNU项目的shell，可以通过ANSI-C引号来表示这些字符。例如，Bash命令`grep $'Λ\tω'`和`grep $'\u039B\t\u03C9'`都是搜索前面提到的同一个三字串`^	ω`。然而，由于Bash在grep看到模式之前就翻译了ANSI-C引号，所以这种技术不应该被用来匹配可打印的ASCII字符；例如，`grep $'\u005E'`相当于`grep '^'`，可以匹配任何一行，而不仅仅是包含字符`^`（U+005E CIRCUMFLEX ACCENT）的行。

由于PCREs和ANSI-C引用是GNU对POSIX的扩展，用ASCII编写的可移植的shell脚本应该使用其他方法来匹配特定的非ASCII字符。例如，在UTF-8地区，`grep "$(printf '\316\233\t\317\211\n')`命令是一个可移植的，尽管很难读懂Bash的`grep $'Λ\tω'`。然而，这些技术都不能把空字符直接放到命令行模式中；空字符只能出现在通过-f（-file）选项指定的模式中。

## 4. 使用

这是一个使用GNU grep的例子：

~~~shell
grep -i 'hello.*world' menu.h main.c
~~~

这将列出menu.h和main.c文件中所有包含`hello`后跟一个`world`的字符串的行；这是因为`.*`在一行中匹配零个或多个字符（参见[正则表达式](##3. 正则表达式)）。-i选项使grep忽略大小写，导致它匹配 "Hello, world!"这一行，否则它就不会匹配。

这里有一个更复杂的例子，显示当前目录下所有名称以非`.`开头、包含`g`、以`.h`结尾的文件中，任何包含`f`和以`.c`结尾的行的位置和内容。-n选项输出行号，--参数将后面的参数视为文件名而非选项，即使*g*.h扩展为以`-`开头的文件名，而空文件/dev/null导致文件名被输出，即使只有一个文件名恰好是`*g*.h`的形式。

~~~shell
grep -n -- 'f.*\.c$' *g*.h /dev/null
~~~

注意，模式中使用的正则表达式语法与shell用来匹配文件名的文件名替换语法不同。

下面是一些个vgrep使用中常见的问题和解答。

1. 如何只列出匹配文件的文件名？

~~~shell
grep -l 'main' test-*.c
~~~

列出当前目录下所有`test-*.c`文件中内容包含`main`的文件的文件名。

2. 如何递归地搜索目录？

~~~shell
grep -r 'hello' /home/gigi
~~~

在`/home/gigi `目录下的所有文件中搜索`hello`。要更加精细地控制那些文件被搜索，使用find和grep。例如，下面的命令仅搜索C

文件：

```shell
find /home/gigi -name '*.c' ! -type d \
  -exec grep -H 'hello' '{}' +
```

这与下一条命令不同：

```shell
grep -H 'hello' /home/gigi/*.c
```

该命令搜索`/home/gigi`下的非隐藏的、以`.c`结尾的C文件。find命令与以下命令更类似：

```shell
grep -r --include='*.c' 'hello' /home/gigi
```

3. 如果模式或者文件名有前导`-`怎么办？例如：

```shell
grep "$pattern" *
```

如果pattern或者由`*`扩展得到的文件名由前导`-`，那么上述命令的行为是不符合预期的。要避免此问题，可以使用-e指定模式并且在文件名前添加前导的`./`：

```shell
grep -e "$pattern" ./*
```

搜索工作目录中所有名称不以`.`开头的文件中与该模式匹配的所有行。如果没有-e，grep可能会把以`-`开头的模式当作一个选项。如果没有`./`，文件名以`-`开头可能会出现类似的问题。

或者，可以在模式和文件名前使用`--`。

```shell
grep -- "$pattern" *
```

这也可以避免上述问题，除非有一个名为`-`的文件，grep将`-`错误地解释为标准输入。

4. 希望搜索整个单词，而不是单词的一部分？

```shell
grep -w 'hello' test*.log
```

只搜索作为整个单词的`hello`实例；它不匹配`Othello`。更加精细地控制可以通过`\<`匹配`\>`单词的开始或者结束。例如：

```shell
grep 'hello\>' test*.log
```

只搜索以`word`结尾的单词，所有它匹配`Othello`。

5. 如何输出匹配行的上下文？

```shell
grep -C 2 'hello' test*.log
```

打印匹配行的前后两行。

6. 如何强制grep输出文件名？

追加/dev/mull：

~~~shell
grep 'eli' /etc/passwd /dev/null
~~~

得到：

```shell
/etc/passwd:eli:x:2098:1000:Eli Smith:/home/eli:/bin/bash
```

或者通过GNU扩展-H：

```shell
grep -H 'eli' /etc/passwd
```

7. 为什么在ps输出上使用奇怪的正则表达式？

```shell
ps -ef | grep '[c]ron'
```

如果这个模式在写的时候不带方括号，那么它不仅会与cron的ps输出行相匹配，也会与grep的ps输出行相匹配。请注意，在某些平台上，ps将输出限制在屏幕的宽度上；而除了可用的内存，grep对一行的长度没有任何限制。

8. 为什么grep报告“二进制文件匹配”？

如果grep从一个二进制文件中列出所有匹配的 "行"，它可能会产生没有用的输出，甚至可能扰乱显示。因此，GNU grep 抑制了那些看起来是二进制文件的输出。要强迫GNU grep从看起来是二进制的文件中输出行，可以使用-a或-binary-files=text选项。要消除 "二进制文件匹配 "的信息，使用-I或-binary-files=without-match选项。

9. 为什么grep -lv不输出非匹配文件名？

grep -lv列出所有包含一个或多个不匹配行的文件名称。要列出不包含匹配行的所有文件的名称，请使用-L或-files-without-match选项。

10. 可以通过`|`进行OR操作，AND操作要怎么做？

```shell
grep 'paul' /etc/motd | grep 'franc,ois'
```

找到所有包含paul和franc,ois的行。

11. 为什么空模式匹配每个输入行？

grep命令搜索包含符合模式的字符串的行。每一行都包含空字符串，所以空模式会使grep在每一行都找到一个匹配的字符串。这不是唯一的模式：`^`、`$`和许多其他模式会使grep匹配每一行。

要匹配空行，使用模式`^$`。要匹配空白行，使用模式`^[[:blank:]]*$`。想要一行也不匹配，使用扩展正则表达式，例如`a^`或者`$a`。要匹配每一行，可移植的脚本应该使用模式`^`而不是空模式，这是因为POSIX没有指定空模式的行为。

12. 如何同时在标准输入和文件中进行搜索？

使用特殊文件名`-`：

```shell
cat /etc/passwd | grep 'alain' - /etc/motd
```

13. 为什么不能将shell的set -e与grep组合使用？

grep命令遵循cmp和diff等程序的惯例，退出状态为1并不是一个错误。shell命令'set -e'会在任何子命令以非零状态退出时导致shell退出，而这将导致shell退出，仅仅是因为grep没有选择任何行，这通常不是预期行为。

Bash的set -e -o pipefail有一个相关的问题。由于grep并不总是读取所有的输入，当grep在读取所有的输入之前退出时，一个输出到grep读取的管道的命令可能会失败，而这个命令的失败会导致Bash退出。

14. 为什么反向引用会失败？

```shell
echo 'ba' | grep -E '(a)\1|b\1'
```

这就会产生一个错误信息，因为第二个`\1`没有什么可以参考的，这意味着它永远不会匹配任何东西。

15. 如何跨行匹配？

标准grep无法做到这一点，因为它从根本上说是基于行的。因此，仅仅使用`[:space:]`字符类并不能以期望的方式匹配换行。

使用GNU grep选项-z (--null-data)，每个输入和输出的 "行 "都是空结尾的；见[其他选项](####2.1.7 其他选项)。因此，可以匹配输入中的换行符，但通常如果有匹配的话，整个输入都会被输出，所以这种用法经常与抑制输出的选项如-q结合使用，例如：

```shell
printf 'foo\nbar\n' | grep -z -q 'foo[[:space:]]\+bar'
```

如果这还不够，可以在给grep之前对输入进行转换，或者求助于awk、sed、perl或其他许多被设计为跨行操作的工具。

16. grep -E,-F 分别代表什么？

grep这个名字来自于Unix系统中的行编辑方式。例如，ed使用下面的语法在屏幕上打印一个匹配行的列表：

```shell
global/regular expression/print
g/re/p
```

选项-E代表扩展grep，-F代表固定grep。

17. 使用egrep和fgrep会发生什么？

第七版Unix有egrep和fgrep命令，是现代grep -E和grep -F的对应命令。尽管将grep分成三个程序在70年代的小型计算机上也许是有用的，但是egrep和fgrep并没有被POSIX标准化，也不再需要了。在当前的GNU实现中，egrep和fgrep会发出一个警告，然后像它们的现代对应程序一样运行；最终，它们被计划完全删除。

如果用户喜欢旧的名字，可以使用自己的替代脚本，比如一个名为egrep的shell脚本，内容如下：

~~~shell
#!/bin/sh
exec grep -E "$@"
~~~

## 5. 性能

通常情况下，grep是搜索文本的一种有效方式。然而，在某些情况下，它可能相当慢，而且它可以搜索大的文件，即使是轻微的性能调整也会有很大帮助。尽管grep使用的算法的实现细节在不同的版本中有所改变，但了解它的基本优点和缺点可以帮助提高其性能。

grep命令的运行部分是通过一组为提高效率而设计的自动机，部分是通过一个较慢的匹配器，当快速匹配器遇到不寻常的特征（如反向参考）时，该匹配器会接管。在可行的情况下，Boyer-Moore快速字符串搜索算法被用来匹配单个固定模式，而Aho-Corasick算法被用来匹配多个固定模式。

一般来说，grep在单字节的locale中运行得更有效，因为它可以避免对多字节字符的特殊处理。如果模式在那样的情况下也能正常工作，那么将LC_ALL设置为单字节的locale可以大大地提高性能。设置'LC_ALL='C''可以特别有效，因为grep是为该locals调整的。

在'C' locale设置之外，不区分大小写的搜索，以及对`[a-z]`和`[=a=]b]`这样的括号表达式的搜索，由于难以对多字符整理元素这样的概念进行快速便携的访问，效率可能会出奇的低。

区间表达式可以通过重复在内部实现。例如，`^(a|bc){2,4}$`可能被实现为`^(a|bc)(a|bc)(a|bc)?)?$`。大的重复次数可能会耗尽内存或大大降低匹配速度。即使是小的计数，如果级联也会引起问题；例如，`grep -E ".*{10,}{10,}{10,}{10,}{10,}`可能会溢出堆栈。幸运的是，像这样的正则表达式通常是人为的，而且级联重复不符合POSIX，所以无论如何不能用于可移植程序中。

像`\1`这样的反向引用在某些情况下会严重影响性能，因为反向引用一般不能通过有限状态自动机来实现，而是要触发一个反向追踪算法，而这个算法的效率可能相当低。例如，尽管模式`^(.*)\1{14}(.*)\2{13}$`只匹配那些长度可以写成非负整数x和y的总和15x+14y的行，但模式匹配器并不执行线性二方分析，而是通过所有可能的匹配字符串进行回溯，使用的算法在最坏情况下是指数级的。

在一些支持有空洞的文件的操作系统上——大量的零区域在二级存储上并不存在，grep可以有效地跳过空洞而不需要读取零。如果使用了-a (--binary-files=text))选项（见[文件和目录选择](####2.1.6 文件和目录选择)），除非同时使用了-z (--null-data))选项（见[其他选项](####2.1.7 其他选项)），否则这种优化是无效的。

为了提高效率，grep并不总是读取它的所有输入。例如，shell命令`sed '/^...$/d' | grep -q X `可以导致grep在读取包含 "X"的一行后立即退出，而不去读取其他的输入数据。这反过来又会导致sed以非零状态退出，因为在grep退出后，sed不能写到它的输出管道。

关于grep使用的算法和相关的字符串匹配算法的更多信息，参考：

-  Aho AV. Algorithms for finding patterns in strings. In: van Leeuwen J. *Handbook of Theoretical Computer Science*, vol. A. New York: Elsevier; 1990. p. 255–300. This surveys classic string matching algorithms, some of which are used by `grep`.
-  Aho AV, Corasick MJ. Efficient string matching: an aid to bibliographic search. *CACM*. 1975;18(6):333–40. https://doi.org/10.1145/360825.360855. This introduces the Aho–Corasick algorithm.
-  Boyer RS, Moore JS. A fast string searching algorithm. *CACM*. 1977;20(10):762–72. https://doi.org/10.1145/359842.359859. This introduces the Boyer–Moore algorithm.
-  Faro S, Lecroq T. The exact online string matching problem: a review of the most recent results. *ACM Comput Surv*. 2013;45(2):13. https://doi.org/10.1145/2431211.2431212. This surveys string matching algorithms that might help improve the performance of `grep` in the future.
-  Hakak SI, Kamsin A, Shivakumara P, Gilkar GA, Khan WZ, Imran M. Exact string matching algorithms: survey issues, and future research directions. *IEEE Access*. 2019;7:69614–37. https://doi.org/10.1109/ACCESS.2019.2914071. This survey is more recent than Faro & Lecroq, and focuses on taxonomy instead of performance.
-  Hume A, Sunday D. Fast string search. *Software Pract Exper*. 1991;21(11):1221–48. https://doi.org/10.1002/spe.4380211105. This excellent albeit now-dated survey aided the initial development of `grep`.

## 6. BUG报告

### 6.1 已知BUG

在`{n,m}`结构中大的重复次数可能导致grep使用大量的内存。此外，某些其他晦涩的正则表达式需要指数级的时间和空间，并可能导致grep耗尽内存。

反向引用会大大减慢匹配速度，因为它们会产生指数级的匹配可能性，会消耗时间和内存来搜索。而且，POSIX关于反向引用的规范有时并不明确。此外，许多正则表达式的实现都有反向引用的错误，会导致程序返回不正确的答案甚至崩溃，而修复这些错误往往是低优先级的：例如，截至2021年，GNU C库的错误数据库中包含了反向引用的错误52、10844、11053、24269和25322，而且几乎没有即将修复的迹象。幸运的是，反向引用很少有用，在实际应用中避免它们应该没有什么麻烦。

## 7. 官方文档

[GNU Grep 3.8](https://www.gnu.org/software/grep/manual/grep.html)
