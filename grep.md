# grep

## grep

grep打印包含一个或多个模式匹配的行。

## 目录

1. 介绍
2. 使用grep
   - 2.1 命令行选项
     - 2.1.1 通用程序信息
     - 2.1.2 匹配控制
     - 2.1.3 一般输出控制
     - 2.1.4 输出行前缀控制
     - 2.1.5 上下文行控制
     - 2.1.6 文件和目录选择
     - 2.1.7 其他选项
   - 2.2 环境变量
   - 2.3 退出状态
3. 正则表达式
4. 使用
5. 性能

## 1 介绍

根据给定的一个或多个模式，grep在输入文件中进行模式匹配。当匹配到某一行时，grep会将该行拷贝到标准输出（默认行为），或者产生其他任何用户通过选项指定的输出。

 虽然grep希望对文本进行匹配，但除了可用内存外，它对输入行长度没有限制，并且可以匹配行内的任意字符。如果输入文件的最后一个字节不是换行符，grep会默默地提供一个。由于换行符也是模式列表的分隔符，因此无法匹配文本中的换行符。 

## 2 使用grep

grep在命令行中通常如下使用

~~~shell
grep [option...] [patterns] [file...]
~~~

命令中有不定数量的可选参数和文件参数。模式参数中包含一个或多个由换行符分割的模式，当通过“-e pattern”或“-f file”选项提供模式时，该参数将被省略。

- 命令行选项
- 环境变量
- 退出状态
- grep程序

### 2.1 命令行选项

grep支持丰富的选项：某些来自POSIX，另一些属于GNU扩展。长的选项名总是GNU扩展，即使是来自POSIX规范的选项。由POSIX指定的选项，在其简短的名称下，被明确地标记为POSIX可移植编程。一些选项的名称是为了与更早或更特殊的实现兼容而提供的。

有几个额外的选项可以控制使用哪个类型的grep匹配引擎。请参考[grep程序]()。

- 通用程序信息
- 匹配控制
- 一般输出控制
- 输出行前缀控制
- 上下文行控制
- 文件和目录选择
- 其他选项

#### 2.2.1 通用程序信息

+ --help

打印一条使用信息，简要地总结命令行选项和错误报告地址，然后退出。

+ -V or --version

打印grep的版本号到标准输出流。这个版本号应该包括在所有的错误报告中。

#### 2.1.2 匹配控制

+ -e patterns or --regexp=patterns

使用*patterns*作为一个或多个模式。模式内的换行符将每个模式与下一个模式分开。如果这个选项被多次使用或者与-f（--file）选项结合使用，则搜索所有给出的模式。通常情况下，当grep在shell命令中使用时，模式应该被加引号（-e是由POSIX指定的）。

+ -f file or --file=file

从*file*中获取*patterns*（每行一个）。如果这个选项被多次使用或者与-e（--regexp）选项结合使用，则搜索所有给出的模式。空文件不包含*patterns*因此不会进行任何匹配（-f是由POSIX指定的）。

+ -i or -y or ----ignore-case

忽略模式和输入数据中的大小写区别，使只有大小写区别的字符相互匹配。当字母只通过小写与大写对进行大小写区分时该选项是明确的，在其他情况下的行为是没有规定的。例如，大写的"S"在许多地区有一个不寻常的小写对应字符"ſ"（Unicode字符U+017F，LATIN SMALL LETTER LONG S），并且没有规定这个不寻常的字符是与"S"还是"s"相匹配，即使大写产生了"S"。另一个例子：德语小写字母"ß"（U+00DF，拉丁文小写字母SHARP S）通常被大写为两个字符串"SS"，但它不匹配 "SS"，也可能不匹配大写字母 "ẞ"（U+1E9E，拉丁文大写字母SHARP S），即使将后者的大小写改为前者。

-y是一个为了兼容而提供的过时选项（-i是由POSIX指定的）。

+ --no-ignore-case

不要忽略模式和输入数据中的大小写区别。这是默认行为。由于该选项与-i会互相覆盖对方，所以-y在传递给早已设置-i选项的shell脚本以抵消其影响时是有用的。

+ -v or --invert-match

反转匹配的含义以选择不匹配的行（-v是由POSIX指定的）

+ -w or --word-regexp

只选择那些含有构成整个单词的匹配内容的行。测试方法是，匹配的子串必须位于该行的开头，或者前面有一个非单词组成的字符。同样地，它必须在行尾，或者后面有一个非单词组成的字符。组成字的字符包括字母、数字和下划线。如果同时指定了-x，这个选项就没有作用。

因为-w选项可以匹配不以单词成分开始和结束的子串，它不同于用'\<'和'\>'包围正则表达式。例如，尽管'grep -w @'可以匹配只包含'@'的行，但是'grep '\<@\>''不能匹配任何行，因为'@'不是一个单词成分。请参考[特殊反斜杠表达式]()。

+ -x or --line-regexp

只选择那些整行匹配的行。对于正则表达式模式，这就像把每个模式放在括号里，然后用'^'和'$'包围（-x是由POSIX指定的）。

#### 2.1.3 一般输出控制

+ -c or --count

压缩正常输出；对于每一个输入文件输出匹配的行数。与-v选项合用输出不匹配的行数（-c是由POSIX指定的）。

+ --color[=WHEN] or --colour[=WHEN]

用转义序列包围匹配的非空字符串、匹配行、上下文行、文件名、行号、字节偏移量和分隔符（对于字段和上下文行的分组），在终端上用颜色显示它们。颜色由环境变量**GREP_COLORS**定义，默认值“ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36”用于显示红色粗体匹配文本、洋红色文件名、绿色行号、绿色字节偏移量、青色分隔符，以及其他默认终端颜色。请参考[环境变量]()。

*WHEN*的值可以是：‘always’始终使用彩色输出；‘never’从不使用彩色输出；‘auto’在标准输出与终端设备关联且*term*环境变量表明终端支持彩色输出时使用彩色输出。朴素的--color选项等同于--color=auto；如果没有指定--color选项时默认--color=never。

+ -L or --files-without-match

压缩正常输出；打印每个输入文件的名称，这些文件通常不会打印输出。

+ -l or --files-with-matches

压缩正常输出。打印每个输入文件的名称，这些文件的输出通常都会被打印出来。对每个输入文件的扫描在第一次匹配时停止（-l是由POSIX指定的）。

+ -m num or --max-count=num

在*num*次匹配后停止。如果*num*是0,grep会立即停止，不会读取输入内容。*num*为-1代笔无穷大，grep不会停止；这是默认情况。

如果输入是来自普通文件的标准输入，并且输出的行的数量达到了*num*，grep确保标准输入在退出前正好位于最后选择的行之后，而不管是否存在后续的上下文行。这使得调用进程能够继续进行搜索。例如，下面的shell脚本就使用了它：

~~~shell
while grep -m 1 'PATTERN'
do
  echo xxxx
done < FILE
~~~

但是下面的shell脚本可能不能正常工作因为pipe不是一个普通文件：

```shell
# This probably will not work.
cat FILE |
while grep -m 1 'PATTERN'
do
  echo xxxx
done
```

当grep在选择了*num*行之后停止时，它会输出任何结尾的上下文行。当同时使用-c或--count选项时，grep不会输出大于num的计数。当同时使用-v或--invert-match选项时，grep在输出*num*个不匹配的行后停止。

+ -o or --only-matching

只打印匹配行中匹配的非空部分，每部分都在单独的输出行中。输出行使用与输入相同的定界符，如果同时使用-z（--null-data），则定界符为空字节（见[其他选项]()）。

+ -q or --quiet or --silent

安静模式；不向标准输出写入任何东西。在任何匹配发生后立即以0状态退出即使检测到错误。请同时参考-s或者--no-messages选项。移植性提示：Solaris 10 版本的grep不支持-q；可移植的shell脚步通常可以将标准输出重定向到/dev/null而不是使用-q（-q是由POSIX指定的）。

+ -s or --no-messages

压缩关于不存在或不可读的文件的错误信息（-s是由POSIX指定的）。

#### 2.1.4 输出行前缀控制

当要输出几个前缀字段时，顺序总是文件名、行号和字节偏移，不管这些选项是按什么顺序指定的。

+ -b or --byte-offset

在每一行的输出前打印其在输入文件内的字节偏移量（从0开始）。如果-o或者--only-matching同时被指定则打印匹配部分自身的偏移量。

+ -H or --with-filename

在每个匹配之前打印文件名。当搜索多个文件时这是默认行为。

+ -h or --no-filename

在输出中压缩文件名前缀。当搜索的文件仅有一个（或者是标准输入）时这是默认行为。

+ --label=LABEL

将实际来自标准输入的输入显示为来自文件LABEL的输入。这对在搜索前转换文件内容的命令很有用；例如：

~~~shell
gzip -cd foo.gz | grep --label=foo -H 'some pattern'
~~~

+ -n or --line-number

在每一行的输出前打印其在输入文件内的行号（从1开始）（-n是由POSIX指定的）。

+ -T or --initial-tab

确保实际行内容的第一个字符位于一个制表符上，以便制表符的对齐方式看起来正常。这对输出内容前缀为实际内容的选项很有用：-H, -n, 和 -b。这也可以为输出的行号和字节偏移量预留空格，这样，来自一个文件的行都从同一列开始。

+ -z or --null

输出一个零字节（ASCII NUL字符），而不是通常在文件名后面的字符。例如，'grep -lZ'在每个文件名后面输出一个零字节，而不是通常的换行。这个选项使输出不模糊，即使在文件名中含有像换行这样的不寻常字符的情况下。这个选项可以与 "find -print0"、"perl -0"、"sort -z "和 "xargs -0 "等命令一起使用，以处理任意的文件名，甚至是那些包含换行符的文件名。

#### 2.1.5 上下文行控制

*上下文行*是匹配行附近的非匹配行。只有当下列选项被使用时他们才会被输出。无论这些选项如何设置，grep不会出入任何给定的行超过一次。如果-o或者--only-matching同时被指定，那么这些选项会实效同时会给出一个告警。

+ -A num or --after-context=num

输出匹配的行后的*num*行。

+ -B num or --before-context=num

输出匹配的行前的*num*行。

+ -C num or -num or --context=num

输出匹配的行前后各*num*行。

+ --group-separator=string

当使用了-A，-B或-C时，在不同的行的分组之间打印*string*而不是--。

+ --no-group-separator

当使用了-A，-B或-C时，不要再不同的行的分组之间打印分隔符。

下面是关于grep如何选择前缀字段和行内容之间的分隔符的一些要点：

+ 匹配行通常使用':'作为前缀字段和实际行内容之间的分隔符。
+ 上下文（即非匹配行）使用'-'代替。
+ 当没有指定上下文时，匹配行只是一个接一个地输出。
+ 当上下文被指定时，在输入中相邻的行形成一个组，并被一个接一个地输出，而默认情况下，在不相邻的组之间会出现一个分隔符。
+ 默认的分隔符是一个"--"行；它的存在和外观可以通过上述选项来改变。
+ 每个组可以包含几个匹配的行，当它们足够接近时，两个相邻的组就会连接起来，可以合并成一个连续的组。

#### 2.1.6 文件和目录选择

+ -a or --text

像处理文本文件一样处理二进制文件；这相当于--binary-files=text选项。

+ --binary-files=type

如果一个文件的数据或元数据表明该文件包含二进制数据，则假定该文件是*type*类型的。非文本字节表示二进制数据；这些字节要么是对当前地域编码不当的输出字节（见[环境变量]()），要么是没有给出-z（-null-data）选项时的空输入字节（见[其他选项]()）。

*type*的默认值是‘binary’，grep在发现空的输入二进制数据后不会输出，同时也不会输出包含不正确编码的数据的行。当某些输出被抑制时，grep会在任何输出之后向标准错误发送一条信息，说有一个二进制文件与之匹配。

如果*type*是‘without-match’，当发现了空的二进制输入数据时，grep会假定文件的剩余部分也不会匹配；着相当于-I选项。

如果*type*是‘text’，grep像处理文本文件一样处理二进制文件；这相当于-a选项。

当*type*为"binary"时，grep可能将非文本字节视为行结束符，即使没有-z（-null-data）选项。这意味着选择“binary”和"text"会影响到一个模式是否与一个文件匹配。例如，当类型为“binary”时，模式 "q$"可能会匹配紧随空字节的"q"，尽管当类型为“text”时，这并不匹配。相反，当类型为“binary”时，模式'.'（句号）可能不匹配空字节。

警告：-a (-binary-files=text)选项可能会输出二进制垃圾，如果输出是一个终端，并且终端驱动程序将其中一些解释为命令，这可能会产生讨厌的副作用。另一方面，在读取文本编码未知的文件时，使用-a或在环境中设置'LC_ALL='C''可能会有帮助，以便找到更多的匹配，即使这些匹配对于直接显示来说是不安全的。

+ -D action or --devices=action

如果输入文件是一个设备、FIFO或套接字，使用action来处理它。如果*action*是“read”，所有的设备都被读取，就像它们是普通文件一样。如果动作是 "skip"，设备、FIFO和套接字会被默默跳过。默认情况下，如果设备在命令行上或者使用了-R（-dereference-recursive）选项，则会被读取，如果设备是递归遇到的，并且使用了-r（-recursive）选项，则会被跳过。这个选项对通过标准输入读取的文件没有影响。

+ -d action or --directories=action

如果输入文件是一个目录，则使用action来处理它。默认情况下，*action*是”read“，这意味着目录被读取，就像它们是普通文件一样（一些操作系统和文件系统不允许这样做，会导致grep为每个目录打印错误信息或默默跳过它们）。如果*action*是"skip"，目录会被默默跳过。如果*action*是'recurse'，grep会递归地读取每个目录下的所有文件，访问命令行符号链接，跳过其他符号链接；这相当于-r选项。

+ --exclude=glob

使用通配符匹配，跳过任何名称后缀与模式*glob*匹配的命令行文件；名称后缀是整个名称，或者是名称中紧随斜线 ('/') 后面以非斜线字符开始的部分。递归搜索时，跳过任何子文件名与 glob 匹配的子文件；子文件名是最后一个斜线之后的部分。模式可以使用'*'、'？'和'['...']'作为通配符，并且使用\可以按字面意思引用通配符或反斜杠字符。

+ --exclude-from=file

跳过那些名称与从*file*中读出的任何模式相匹配的文件（使用通配符匹配，如--exclude下所述）。

+ --exclude-dir=glob

跳过任何名称后缀与*glob*模式相匹配的命令行目录。当进行递归搜索时，跳过任何其基本名称与*glob*相匹配的子目录。忽略*glob*中任何多余的尾部斜线。

+ -I

相当于--binary-files=without-match选项。

+ --include=glob

只搜索名称与*glob*匹配的文件，使用如--exclude所述的通配符匹配。如果同时提供了矛盾的--include和-exclude选项，那么后匹配的会生效。如果没有--include或--exclude匹配，文件就会被包含，除非第一个这样的选项是--include。

+ -r or --recursive

对于每个目录操参数，以递归方式读取和处理该目录中的所有文件。访问命令行中的符号链接，但跳过递归遇到的符号链接。注意，如果没有给出文件参数，grep会搜索工作目录。这与--directories=recurse选项相同。

+ -R or --dereference-recursive

对于每个目录参数，读取和处理该目录中的所有文件，递归地处理所有符号链接。

#### 2.1.7 其他选项

+ --

界定选项列表。--后面的参数即使以-开头也会被当作待处理文件。例如，'grep PAT -- -file1 file2'在名为-file1和file2的文件中搜索模式PAT。

+ --line-buffered

对标准输出使用行缓冲，不管输出设备如何。默认情况下，对于交互式设备，标准输出是行缓冲的，否则是全缓冲的。在全缓冲的情况下，输出缓冲区在满时被刷新；在行缓冲的情况下，每输出一行后都会刷新缓冲区。缓冲区的大小取决于系统。

+ -U or --binary

在区分文本和二进制I/O的平台上，当读写用户终端以外的文件时，使用后者，这样所有的输入字节都被原样读写。这覆盖了默认行为，即grep遵循操作系统的建议，使用文本或二进制I/O。在MS-Windows上，当grep使用文本I/O时，它将回车-换行读作换行，将Control-Z读作文件结束，并将换行写作回车-换行对。

+ -z or --null-data

将输入和输出的数据视为行的序列，每个行以一个零字节（ASCII NUL字符）代替换行来结束。和-Z或--null选项一样，这个选项可以和'sort -z'等命令一起使用，以处理任意的文件名。

### 2.2 环境变量

grep的行为受到数个环境变量的影响，其中最重要的是locale，该变量决定了个grep如何解释模式和数据中的字符。

LC_foo类别的locale是通过依次检查三个环境变量LC_ALL、LC_foo和LANG。这些变量中，第一个被设置的变量指定了locale。例如，如果LC_ALL没有被设置，但是LC_COLLATE被设置为'pt_BR.UTF-8'，那么LC_COLLATE类别就使用了巴西葡萄牙语的语言环境。作为一个仅适用于LC_MESSAGES的特殊情况，环境变量LANGUAGE可以包含一个用冒号分隔的语言列表，它覆盖了通常指定LC_MESSAGES类别的三个环境变量。如果没有设置这些环境变量、安装locale目录或者grep在编译时没有使用国家语言支持（NLS），则使用'C'语言。shell命令locale -a列出了当前可用的locale。

下列环境变量影响grep的行为。

+ GREP_COLOR

这个过时的变量与GREP_COLORS的交互作用令人困惑，如果它被设置而没有被GREP_COLORS所覆盖，grep会发出警告。可以用 "GREP_COLOR='mt=color'"来代替 "GREP_COLOR='color'"。

+ GREP_COLORS

该变量指定了颜色和其他属性以高亮输出中的不同部分。

它的值是一个用冒号分隔的*terminfo*功能列表，默认为`ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36`，`rv`和`ne`被省略（即为false）。两字母功能名称指的是终端“功能”，即高亮文本或改变文本颜色等能力。这些功能存储在一个在线数据库并由*terminfo*访问。非空的功能值通过终端或终端仿真器解释的选择图形渲染（SGR）命令来控制高亮显示(关于允许的值及其作为字符属性的含义，请参见文本终端文档中的章节）。

这些子串值是十进制的整数，可以用分号连接。grep负责将结果组合成一个完整的SGR序列（'\33['...'m'）。常见的连接值包括'1'表示粗体，'4'表示下划线，'5'表示闪烁，'7'表示反色，'39'表示默认前景色，'30'到'37'表示前景色，'90'到'97'表示16色模式前景色，'38;5;0'到'38;5;255'用于88色和256色模式的前景色，'49'用于默认背景色，'40'到'47'用于背景色，'100'到'107'用于16色模式的背景色，'48;5;0'到'48;5;255'用于88色和256色模式的背景色。

支持的功能如下。

sl= ：整个选定行的SGR子串（即省略-v命令行选项时的匹配行，或指定-v时的非匹配行）。然而，如果同时指定了布尔功能'rv'和-v命令行选项，它将适用于上下文匹配的行。默认是空的（即终端的默认颜色对）。

cx= ：SGR子串适用于整个上下文行（即省略-v命令行选项时的非匹配行，或指定-v时的匹配行）。然而，如果同时指定了布尔功能'rv'和-v命令行选项，它就会适用于选定的非匹配行。默认是空的（即终端的默认颜色对）。

rv ：布尔值，当指定-v命令行选项时，将'sl='和'cx='能力的含义反转（交换）。默认值是false（即忽略该功能）。

mt=01;31 ：SGR子串，用于匹配任何匹配行中的非空文本（即省略-v命令行选项时的选定行，或指定-v时的上下文行）。设置它相当于将'ms='和'mc='同时设置为相同的值。默认是在当前行的背景上有一个粗体的红色文本前景。

ms=01;31 ：SGR子字符串，用于匹配选定行中的非空文本（这只在省略了-v命令行选项的情况下使用）。当它生效时，`‘sl=’ (or ‘cx=’ if ‘rv’)`功能的效果仍然有效。默认情况是在当前行的背景上有一个粗体的红色文本前景。

mc=01;31 ：SGR子串，用于匹配上下文行中的非空文本（这只在指定了-v命令行选项时使用）。当它生效时，`'cx=’ (or ‘sl=’ if ‘rv’)`功能的效果仍然有效。默认是在当前行的背景上有一个粗体的红色文本前景。

fn=35 ：SGR子串，用于文件名前的任何内容行。默认是在终端的默认背景上有一个洋红色的文本前景。

ln=32 ：用于任何内容行前的行号的SGR子串。默认是在终端的默认背景上有一个绿色的文本前景。

bn=32 ：用于任何内容行前的字节偏移的SGR子串。默认是在终端的默认背景上有一个绿色的文本前景。

se=36 ：用于分隔符的SGR子串，在选定的行域（':'）之间、上下文行域（'-'）之间以及指定非零上下文时相邻行分组之间插入（'--'）。默认情况是在终端的默认背景上有一个青色的文本前景。

ne ：布尔值，防止每次着色项目结束时，使用行内擦除（EL）向右清除到行尾（'\33[K'）。这在不支持EL的终端上是需要的。另外，当所选择的高亮颜色不影响背景时，或者当EL太慢或导致太多闪烁时，它在``back_color_erase` (`bce`)` boolean *terminfo*功能不适用的终端上很有用。默认为false（即忽略该功能）。

注意布尔功能没有`'='... `部分。它们在默认情况下是被忽略（即false），当被指定时就变成了true。

+ LC_ALL and LC_COLLATE and LANG

这些变量指定了LC_COLLATE类别的区域设置，这可能会影响像'a-z'这样的范围表达式的解释。

+ LC_ALL and LC_CTYPE and LANG

这些变量为LC_CTYPE类别指定了区域设置，它决定了字符的类型，例如，哪些字符是空白的。这个类别还决定了字符编码。参见[字符编码]()。

+ LANGUAGE and LC_ALL and LC_MESSAGES and LANG

这些变量指定了LC_MESSAGES类别的locale，它决定了grep对信息使用的语言。默认的"C"区域设置使用美式英语信息。

+ POSIXLY_CORRECT

如果设置了，grep的行为符合POSIX的要求；否则，grep的行为更像其他GNU程序。POSIX要求在文件名后面的选项必须被视为文件名；默认情况下，这类选项会被换位到操作数列表的前面并被视为选项。

+ TERM

这个变量指定了输出终端的类型，它可以影响--color选项的作用。见[一般输出控制]()。

+ \_N_GNU_nonoption_argv_flags\_

（这里N是grep的数字pid）如果这个环境变量的第1个字符是'1'，不要把grep的第1个操作数看作是一个选项，即使它看起来是一个。shell可以为它运行的每个命令在环境中加入这个变量，指定哪些操作数是文件名通配符扩展的结果，因此不应该被当作选项。这种行为只适用于GNU C库，而且只有在没有设置POSIXLY_CORRECT的情况下。

不再支持grep 2.20和更早版本的GREP_OPTIONS环境变量，因为它在编写可移植脚本时引起了问题。要对grep的工作方式进行任意改变，你可以使用别名或脚本来代替。例如，如果grep在"/usr/bin "目录下，你可以将$HOME/bin预置到你的PATH中，并创建一个包含以下内容的可执行脚本$HOME/bin/grep：

~~~shell
#! /bin/sh
export PATH=/usr/bin
exec grep --color=auto --devices=skip "$@"
~~~

### 2.3 退出状态

通常情况下，如果有一行被选中则退出状态为0，没有行被选中则退出状态为1，发生错误则退出状态为2。然而如果-q或者--quiet或者--silent选项被指定并且有一行被选中，那么即使发生错误退出状态也是0。其他grep实现可能会在发生错误时以大于2的状态退出。

### 2.4 grep程序

grep在指定的输入文件中搜索包含与给定模式匹配的行。默认情况下，grep打印出匹配的行。一个名为-的文件代表标准输入。如果没有指定输入，grep会搜索工作目录。如果给定的命令行选项指定了递归，则grep会搜索标准输入。grep有四个主要的变体，由下列选项控制。

+ -G or --basic-regexp

将模式解释为基本正则表达式（BREs）。这是默认的。

- -E or --extended-regexp

将模式解释为扩展正则表达式（ERE）（-E是由POSIX指定的）。

- -F or --fixed-strings

将模式解释为固定字符串，而不是正则表达式(-F是由POSIX指定的)。

+ -P or --perl-regexp

将模式解释为与Perl兼容的正则表达式（PCREs）。对PCRE的支持将继续下去，但是当这个选项与-z（-null-data）选项结合使用时，请考虑这个选项的实验性，并注意 "grep -P "可能会对未实现的功能发出警告。

## 3. 正则表达式

正则表达式是一种描述一组字符串的模式。正则表达式的构造类似于算术表达式，通过使用各种运算符来组合较小的表达式。grep 可以理解三种不同版本的正则表达式语法：基本（BRE）、扩展（ERE）和 Perl-compatible（PCRE）。在GNU grep中，基本语法和扩展语法之间的可用功能没有区别。在其他实现中，基本正则表达式的功能较少。下面的描述适用于扩展正则表达式；基本正则表达式的差异将在后面总结。与 Perl 兼容的正则表达式提供了额外的功能，并在 pcre2syntax(3) 和 pcre2pattern(3) 手册页中有记录，但只有在系统中存在 PCRE 的情况下才能工作。

+ 基本结构
+ 字符类和括号表达式
+ 锚定
+ 反向引用和子表达式
+ 正则表达式：基本 vs 扩展
+ 问题正则表达式
+ 字符编码
+ 匹配非ASCII和不可打印字符

### 3.1 基本结构

在正则表达式中，`.?*+{|()[\^$`是特殊字符，作用如下所述。所有其他字符都是普通字符，每一个普通字符都是匹配自身的正则表达式。

句号`.`匹配任何的单个字符。`.`是否匹配错误编码是未定义的。

一个正则表达式之后可以跟随一个或数个重复操作符；以`{`开头的操作符被称为间隔操作符。

+ ? ：字符是可选的，至多匹配一次。
+ \* ：字符可匹配0次或多次。
+ \+ ：字符至少匹配一次。
+ {n} ：字符正好匹配n次。
+ {n,} ：字符至少匹配n次。
+ {,m} ：字符至多匹配m次。这是GNU扩展
+ {n,m} ：字符匹配n到m次。

空正则表达式匹配的是空字符串。两个正则表达式可以被连接起来；产生的正则表达式匹配任何由两个分别匹配连接的表达式的子字符串组成的字符串。

两个正则表达式可以用运算符`|`连接。由此产生的正则表达式可以匹配任何与这两个表达式中的任何一个相匹配的字符串，成为替代表达式。

重复优先于连接，连接又优先于替代。整个表达式可以用括号括起来，以覆盖这些优先规则并形成子表达式。不匹配的`)`仅与自身匹配。 

并不是每个字符串都是有效的正则表达式。参考[问题正则表达式]()。

### 3.2 字符类和括号表达式